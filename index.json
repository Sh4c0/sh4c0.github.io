[{"categories":["2021/8"],"content":"ä¼ é€é—¨ ","date":"2021-08-28","objectID":"/posts/cf1562e/:0:0","tags":["codeforces","suffix array","sparse table"],"title":"Cf1562E Rescue Niwen!","uri":"/posts/cf1562e/"},{"categories":["2021/8"],"content":"é¢˜æ„ å°†ä¸€ä¸ªå­—ç¬¦ä¸²æŒ‰å¦‚ä¸‹å½¢å¼æ‹†åˆ†ä¸ºè‹¥å¹²ä¸ªä¸²ï¼š ä»¥$abcd$ä¸ºä¾‹ï¼Œæ‹†åˆ†ä¸º$a,ab,abc,abcd,b,bc,bcd,c,cd,d$ è¾“å‡ºæœ€é•¿çš„å­—å…¸åºä¸¥æ ¼ä¸Šå‡çš„å­åºåˆ—ï¼ˆå¯ä»¥ä¸è¿ç»­ï¼‰çš„é•¿åº¦ ","date":"2021-08-28","objectID":"/posts/cf1562e/:0:1","tags":["codeforces","suffix array","sparse table"],"title":"Cf1562E Rescue Niwen!","uri":"/posts/cf1562e/"},{"categories":["2021/8"],"content":"æ€è·¯ å°†æ‰€æœ‰ä¸²æŒ‰åŸä¸²åç¼€åˆ†ç»„ å¯¹äºä»»æ„åç¼€$i$ï¼Œå…¶æœ€å¤§è´¡çŒ®ä¸º$n-i+1$ï¼Œå½“ä¸”ä»…å½“åç¼€$j\u003ei$ä¸”$rk[j]\u003erk[i]$æ—¶ï¼Œåç¼€$j$å¯ç½®äºåç¼€$i$ä¹‹åï¼Œä¸”è´¡çŒ®åº¦ä¸º$n-i+1-lcp(i,j)$ ","date":"2021-08-28","objectID":"/posts/cf1562e/:0:2","tags":["codeforces","suffix array","sparse table"],"title":"Cf1562E Rescue Niwen!","uri":"/posts/cf1562e/"},{"categories":["2021/8"],"content":"ä»£ç  #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int maxn=5e3+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; ll ans[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=75; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]-'0'+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } int st[maxn][30],plg[maxn]; void ST_pre(){ plg[1]=0; for(int i=2;i\u003c=n;i++)plg[i]=plg[i/2]+1; for(int i=1;i\u003c=n;i++)st[i][0]=ht[i]; for(int j=1;j\u003c=plg[n];j++){ for(int i=1;i\u003c=n-(1\u003c\u003cj)+1;i++){ st[i][j]=min(st[i][j-1],st[i+(1\u003c\u003c(j-1))][j-1]); } } } int ST_query(int l,int r){ int k=plg[r-l+1]; return min(st[l][k],st[r-(1\u003c\u003ck)+1][k]); } int lcp(int a,int b){//æ’åç¬¬açš„åç¼€ä¸æ’åç¬¬bçš„åç¼€çš„æœ€é•¿å…¬å…±å‰ç¼€ if(a\u003eb)swap(a,b); return ST_query(a+1,b); } inline void solve(){ cin\u003e\u003en\u003e\u003e(s+1); SuffixArray(); Height(); ST_pre(); ll res=0; for(int i=1;i\u003c=n;i++){ int x=sa[i]; ans[x]=n-x+1; for(int j=1;j\u003ci;j++){ if(sa[j]\u003cx)ans[x]=max(ans[x],ans[sa[j]]+n-x+1-lcp(j,i)); } res=max(res,ans[x]); } cout\u003c\u003cres\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-08-28","objectID":"/posts/cf1562e/:0:3","tags":["codeforces","suffix array","sparse table"],"title":"Cf1562E Rescue Niwen!","uri":"/posts/cf1562e/"},{"categories":["2021/8"],"content":"å°ç»“ æœ€è¿‘ä¸€ç›´åœ¨å­¦çš„åç¼€æ•°ç»„å±…ç„¶ç°åœºé‡åˆ°äº†æ²¡åšå‡ºæ¥ï¼ŒçœŸæ˜¯ç¦»ç´«åæœ€è¿‘çš„ä¸€ä¼š ğŸ˜­ ","date":"2021-08-28","objectID":"/posts/cf1562e/:0:4","tags":["codeforces","suffix array","sparse table"],"title":"Cf1562E Rescue Niwen!","uri":"/posts/cf1562e/"},{"categories":["2021/8"],"content":"ä¼ é€é—¨ ","date":"2021-08-25","objectID":"/posts/poj3463/:0:0","tags":["poj","dijkstra"],"title":"POJ3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"é¢˜æ„ ç»™ä¸€å¼ å›¾ï¼Œæ±‚åˆ°ç»ˆç‚¹æœ€çŸ­è·¯ä¸ªæ•°ä»¥åŠä¸æœ€çŸ­è·¯ç›¸å·®ä¸º1çš„æ¬¡çŸ­è·¯çš„ä¸ªæ•°ä¹‹å’Œ ","date":"2021-08-25","objectID":"/posts/poj3463/:0:1","tags":["poj","dijkstra"],"title":"POJ3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"æ€è·¯ æœ€çŸ­è·¯è®¡æ•°å’Œæ¬¡çŸ­è·¯è®¡æ•°çš„æ¨¡æ¿é¢˜ï¼Œå°†æ¬¡çŸ­è·¯ä¸¢å…¥ä¼˜å…ˆé˜Ÿåˆ—ä¸­å³å¯ã€‚ ","date":"2021-08-25","objectID":"/posts/poj3463/:0:2","tags":["poj","dijkstra"],"title":"POJ3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"ä»£ç  /** * Author: ShacozzZ * Created: 2021-08-25 21:23:21 **/ #include\u003calgorithm\u003e#include\u003ciostream\u003e#include\u003cmap\u003e#include\u003cqueue\u003e#include\u003cvector\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef long long ll; typedef pair\u003cint,int\u003e P; const int inf=0x3f3f3f3f; const int maxn=1e5+5; int n,m; struct edge{ int v,w; edge(){} edge(int vv,int ww){v=vv;w=ww;} }; struct node{ int x,y,z; node(){} node(int xx,int yy,int zz){x=xx;y=yy;z=zz;} bool operator\u003e(const node \u0026b)const{return x\u003eb.x;} }; vector\u003cedge\u003e g[maxn]; int st,en,dis1[maxn],dis2[maxn],cnt1[maxn],cnt2[maxn]; void init(){ for(int i=0;i\u003c=n;i++){ g[i].clear(); dis1[i]=dis2[i]=inf; cnt1[i]=cnt2[i]=0; } } void dij(){ priority_queue\u003cnode,vector\u003cnode\u003e,greater\u003cnode\u003e\u003e q; dis1[st]=0; cnt1[st]=1; q.push(node(0,st,1)); while(!q.empty()){ node p=q.top(); q.pop(); int u=p.y; int d=p.x; int num=(p.z==1?cnt1[u]:cnt2[u]); if(p.z==1\u0026\u0026dis1[u]\u003cp.x)continue; if(p.z==2\u0026\u0026dis2[u]\u003cp.x)continue; for(int i=0;i\u003cg[u].size();i++){ int v=g[u][i].v,w=g[u][i].w; if(d+w\u003cdis1[v]){ dis2[v]=dis1[v]; cnt2[v]=cnt1[v]; q.push(node(dis2[v],v,2)); dis1[v]=d+w; cnt1[v]=num; q.push(node(dis1[v],v,1)); }else if(d+w==dis1[v])cnt1[v]+=num; else if(d+w\u003cdis2[v]){ dis2[v]=d+w; cnt2[v]=num; q.push(node(dis2[v],v,2)); }else if(d+w==dis2[v])cnt2[v]+=num; } } } inline void solve(){ cin\u003e\u003en\u003e\u003em; int u,v,w; init(); for(int i=0;i\u003cm;i++){ cin\u003e\u003eu\u003e\u003ev\u003e\u003ew; g[u].push_back(edge(v,w)); } cin\u003e\u003est\u003e\u003een; dij(); cout\u003c\u003c(dis2[en]-dis1[en]==1?cnt1[en]+cnt2[en]:cnt1[en])\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-08-25","objectID":"/posts/poj3463/:0:3","tags":["poj","dijkstra"],"title":"POJ3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"å°ç»“ å¯¹æœ€çŸ­è·¯çš„ç†è§£åˆåŠ æ·±äº†ï¼ˆå¥½è€¶ ","date":"2021-08-25","objectID":"/posts/poj3463/:0:4","tags":["poj","dijkstra"],"title":"POJ3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"ä¼ é€é—¨ ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:0","tags":["gym","dp","tree"],"title":"2021CCPCä¸œåŒ—å››çœèµ›C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"é¢˜æ„ é—®æœ‰å¤šå°‘ç§åˆ ç‚¹æ–¹æ¡ˆä½¿å¾—å‰©ä¸‹çš„ç‚¹è‡³å°‘ä¸ä¸€ä¸ªç‚¹ç›¸è¿ ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:1","tags":["gym","dp","tree"],"title":"2021CCPCä¸œåŒ—å››çœèµ›C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"æ€è·¯ å®šä¹‰$dp[i][0/1/2]$ä»£è¡¨å¯¹äºèŠ‚ç‚¹iä¸ºæ ¹çš„å­æ ‘ï¼Œå°†èŠ‚ç‚¹$i$åˆ å»ã€ä¿ç•™èŠ‚ç‚¹$i$ä¸”èŠ‚ç‚¹$i$åªä¸çˆ¶èŠ‚ç‚¹ç›¸è¿ã€ä¿ç•™èŠ‚ç‚¹$i$ä¸”ä¸å­èŠ‚ç‚¹ç›¸è¿çš„æ–¹æ¡ˆæ•° å¯¹äºç¬¬ä¸‰ç§æƒ…å†µï¼Œé€šè¿‡å…ˆç®—å¾—ä¿ç•™èŠ‚ç‚¹içš„æ‰€æœ‰æ–¹æ¡ˆæ•°å‡å»ä¸åˆæ³•çš„æ–¹æ¡ˆæ•°ï¼Œå³å‡å»ç¬¬äºŒç§æƒ…å†µçš„æ–¹æ¡ˆæ•° çŠ¶æ€è½¬ç§»æ–¹ç¨‹å¦‚ä¸‹ï¼š $dp[u][0]=\\prod_{v\\in son_{u}}(dp[v][0]+dp[v][2])$ $dp[u][1]=\\prod_{v\\in son_{u}}dp[v][0]$ $dp[u][2]=\\prod_{v\\in son_{u}}(dp[v][0]+dp[v][1]+dp[v][2])-dp[u][1]$ ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:2","tags":["gym","dp","tree"],"title":"2021CCPCä¸œåŒ—å››çœèµ›C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"ä»£ç  #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int md=998244353; const int maxn=2e5+5; int n,m; ll dp[maxn][3]; vector\u003cint\u003e g[maxn]; void dfs(int u,int fa){ for(int v:g[u]){ if(v==fa)continue; dfs(v,u); dp[u][0]=dp[u][0]*(dp[v][0]+dp[v][2])%md;; dp[u][1]=dp[u][1]*dp[v][0]%md; dp[u][2]=dp[u][2]*(dp[v][0]+dp[v][1]+dp[v][2])%md; } dp[u][2]-=dp[u][1]; if(dp[u][2])dp[u][2]+=md; } inline void solve(){ cin\u003e\u003en; for(int i=1;i\u003c=n;i++)dp[i][0]=dp[i][1]=dp[i][2]=1,g[i].clear(); int u,v; for(int i=1;i\u003cn;i++){ cin\u003e\u003eu\u003e\u003ev; g[u].push_back(v); g[v].push_back(u); } dfs(1,0); cout\u003c\u003c(dp[1][0]+dp[1][2])%md\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:3","tags":["gym","dp","tree"],"title":"2021CCPCä¸œåŒ—å››çœèµ›C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"å°ç»“ è®­ç»ƒèµ›è¡¥é¢˜ï¼Œç¦»è°±çš„äº‹åœ¨è®­ç»ƒèµ›æ—¶æ‰‹åŠ¨æ¨¡æ‹Ÿéƒ½æ²¡æœ‰æ•°å‡ºæ ·ä¾‹ä¸­çš„22ç§æ–¹æ¡ˆï¼ˆç¬‘ï¼‰ ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:4","tags":["gym","dp","tree"],"title":"2021CCPCä¸œåŒ—å››çœèµ›C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/7"],"content":"ä¼ é€é—¨ ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:0","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"é¢˜æ„ ç»™ä¸€ä¸ªæ•°ç»„ï¼Œåˆ†å‰²æˆä¸‰ä¸ªåŒºé—´ï¼Œä½¿å¾—å·¦åŒºé—´çš„æœ€å¤§å€¼ç­‰äºä¸­é—´åŒºé—´çš„æœ€å°å€¼ç­‰äºå³åŒºé—´çš„æœ€å¤§å€¼ ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:1","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"æ€è·¯ é¦–å…ˆç”¨çº¿æ®µæ ‘ç»´æŠ¤åŒºé—´çš„æœ€å¤§å€¼æœ€å°å€¼ä¸éš¾æƒ³åˆ°ï¼Œç„¶åéå†æ•°ç»„ï¼Œå†ç¡®å®šä¸€ä¸ªæ–­ç‚¹çš„æ¡ä»¶ï¼ˆå³ç¡®å®šäº†å·¦åŒºé—´ï¼‰ä¸‹ï¼Œå‘ç°å¦å¤–ä¸€ä¸ªæ–­ç‚¹æ‰€ç¡®å®šçš„ä¸¤ä¸ªåŒºé—´çš„æœ€å¤§å€¼å’Œæœ€å°å€¼éƒ½æ˜¯å…·æœ‰å•è°ƒæ€§çš„ï¼Œå³ï¼šä¸­é—´åŒºé—´è¶Šå¤§åˆ™æœ€å°å€¼è¶Šå°ä¸”å³åŒºé—´æœ€å¤§å€¼è¶Šå° æ—¶é—´å¤æ‚åº¦$O(nlognlogn)$ ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:2","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"ä»£ç  #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int inf=0x3f3f3f3f; const int maxn=2e5+5; int n,m,a[maxn]; ll num[maxn]; struct seq_node{ int l,r; ll mn,mx; }tree[maxn\u003c\u003c2]; inline void pushup(int o){ tree[o].mn=min(tree[o\u003c\u003c1].mn,tree[o\u003c\u003c1|1].mn); tree[o].mx=max(tree[o\u003c\u003c1].mx,tree[o\u003c\u003c1|1].mx); } void build_tree(int l,int r,int o){ tree[o].l=l,tree[o].r=r; if(l==r){ tree[o].mx=tree[o].mn=num[l]; return ; } int mid=(l+r)\u003e\u003e1; build_tree(l,mid,o\u003c\u003c1); build_tree(mid+1,r,o\u003c\u003c1|1); pushup(o); } int query_mx(int l,int r,int o){ if(tree[o].l\u003e=l\u0026\u0026tree[o].r\u003c=r)return tree[o].mx; int mid=(tree[o].l+tree[o].r)\u003e\u003e1; int mx=0; if(l\u003c=mid)mx=max(mx,query_mx(l,r,o\u003c\u003c1)); if(r\u003emid)mx=max(mx,query_mx(l,r,o\u003c\u003c1|1)); return mx; } int query_mn(int l,int r,int o){ if(tree[o].l\u003e=l\u0026\u0026tree[o].r\u003c=r)return tree[o].mn; int mid=(tree[o].l+tree[o].r)\u003e\u003e1; int mn=inf; if(l\u003c=mid)mn=min(mn,query_mn(l,r,o\u003c\u003c1)); if(r\u003emid)mn=min(mn,query_mn(l,r,o\u003c\u003c1|1)); return mn; } inline void solve(){ cin\u003e\u003en; for(int i=1;i\u003c=n;i++)cin\u003e\u003enum[i]; build_tree(1,n,1); for(int i=1;i\u003cn-1;i++){ int l=i+1,r=n-1; int mx1=query_mx(1,i,1),mn,mx2; while(l\u003c=r){ int mid=(l+r)\u003e\u003e1; // ck(mid) mn=query_mn(i+1,mid,1); mx2=query_mx(mid+1,n,1); if(mn\u003emx1||mx2\u003emx1)l=mid+1; else if(mn\u003cmx1||mx2\u003cmx1)r=mid-1; else{ cout\u003c\u003c\"YES\"\u003c\u003cendl; cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cmid-i\u003c\u003c\" \"\u003c\u003cn-mid\u003c\u003cendl; return ; } } } cout\u003c\u003c\"NO\"\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:3","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"å°ç»“ å¤§æ¦‚æ˜¯ç¨å¾®å¤ä¹ äº†ä¸€ä¸‹çº¿æ®µæ ‘ï¼ŒäºŒåˆ†çš„æ€è·¯å¾ˆå·§å¦™ï¼Œä¹Ÿæ˜¯é€šè¿‡çœ‹äº†åˆ«äººçš„é¢˜è§£æ‰æƒ³åˆ°çš„ ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:4","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"ä¼ é€é—¨ ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:0","tags":["codeforces","dfs"],"title":"Codeforces1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"é¢˜æ„ ç»™nä¸ªç‚¹næ¡è¾¹çš„æ— å‘å›¾ï¼Œæ±‚æœ‰å¤šå°‘æ¡ç®€å•è·¯å¾„ ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:1","tags":["codeforces","dfs"],"title":"Codeforces1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"æ€è·¯ ä¸éš¾å‘ç°å›¾ä¸ºä¸€æ£µæ ‘å¢åŠ ä¸€æ¡è¾¹ä½¿å¾—æ ‘ä¸­å‡ºç°äº†ä¸€ä¸ªç¯ï¼Œé¦–å…ˆæ‰¾å‡ºç¯ï¼Œç„¶åå¦‚æœä¸¤ä¸ªç‚¹ä¹‹é—´ç»è¿‡ç¯ï¼Œåˆ™æœ‰ä¸¤æ¡ç®€å•è·¯å¾„ï¼Œå¦åˆ™ä¸ºä¸€æ¡ é€šè¿‡ä¸¤æ¬¡dfsï¼Œç¬¬ä¸€æ¬¡æ‰¾å‡ºæœ‰å“ªäº›ç‚¹åœ¨ç¯ä¸Šï¼Œç¬¬äºŒæ¬¡è®¡ç®—ç­”æ¡ˆ ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:2","tags":["codeforces","dfs"],"title":"Codeforces1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"ä»£ç  #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int maxn=2e5+5; const int maxm=1e9; ll n,m,ans; vector\u003cint\u003e g[maxn]; set\u003cint\u003e c; bool vis[maxn]; int fa[maxn]; bool ok=0; void init(){} void dfs1(int u){ vis[u]=1; for(int i=0;i\u003cg[u].size();i++){ if(ok)return ; int v=g[u][i]; if(v!=fa[u]){ if(vis[v]){ while(u!=v){ c.insert(u); u=fa[u]; } c.insert(v); ok=1; }else{ fa[v]=u; dfs1(v); } } } } ll dfs2(int u){ ll res=1; vis[u]=1; for(int i=0;i\u003cg[u].size();i++){ int v=g[u][i]; if(!vis[v]\u0026\u0026(!c.count(u)||!c.count(v))){ res+=dfs2(v); } } return res; } inline void solve(){ cin\u003e\u003en; for(int i=0;i\u003c=n;i++){ g[i].clear(); vis[i]=0; } c.clear(); ans=ok=0; for(int i=1;i\u003c=n;i++){ int u,v; cin\u003e\u003eu\u003e\u003ev; g[u].push_back(v); g[v].push_back(u); } dfs1(1); for(int i=0;i\u003c=n;i++)vis[i]=0; for(int i=1;i\u003c=n;i++){ if(!vis[i]){ ll res=dfs2(i); ans+=res*(res-1)/2+res*(n-res); } } cout\u003c\u003cans\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:3","tags":["codeforces","dfs"],"title":"Codeforces1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"å°ç»“ å¾ˆç®€å•çš„ä¸€ä¸ªé¢˜ï¼Œé›¶é›¶ç¢ç¢çš„bugæ‰¾äº†å¤ªä¹…äº† ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:4","tags":["codeforces","dfs"],"title":"Codeforces1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"ä¼ é€é—¨ ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:0","tags":["codeforces","topological sorting"],"title":"Codeforces1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"é¢˜æ„ ç»™ä¸€ä¸ªå›¾åŒ…å«æœ‰å‘è¾¹å’Œæ— å‘è¾¹ï¼Œå°†æ‰€æœ‰æ— å‘è¾¹æ”¹ä¸ºæœ‰å‘è¾¹å¹¶ä¸”ä½¿å›¾ä¸­ä¸å­˜åœ¨ç¯ ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:1","tags":["codeforces","topological sorting"],"title":"Codeforces1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"æ€è·¯ é¦–å…ˆåˆ é™¤æ‰æ‰€æœ‰æœ‰å‘è¾¹ï¼Œé€šè¿‡æ‹“æ‰‘æ’åºåˆ¤æ–­æ˜¯å¦æœ‰ç¯ï¼Œå¦‚æœä¸å­˜åœ¨ç¯ï¼Œåˆ™å°†æ— å‘è¾¹æ”¹ä¸ºç”±æ‹“æ‰‘åºå°çš„ç‚¹æŒ‡å‘æ‹“æ‰‘åºå¤§çš„ç‚¹çš„æœ‰å‘è¾¹ ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:2","tags":["codeforces","topological sorting"],"title":"Codeforces1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"ä»£ç  #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef pair\u003cint,int\u003e Pii; const int maxn=2e5+5; int n,m,rk[maxn]; vector\u003cPii\u003e e; void init(){} vector\u003cint\u003e g[maxn]; vector\u003cint\u003e topo; int vis[maxn]; bool dfs(int u){ vis[u]=-1; for(auto v:g[u]){ if(vis[v]\u003c0)return 0; else if(!vis[v]\u0026\u0026!dfs(v))return 0; } vis[u]=1; topo.push_back(u); return 1; } bool toposort(){ topo.clear(); for(int i=0;i\u003c=n;i++)vis[i]=0; for(int u=1;u\u003c=n;u++){ if(!vis[u]\u0026\u0026!dfs(u))return 0; } reverse(topo.begin(),topo.end()); return 1; } inline void solve(){ cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++){ vis[i]=0; g[i].clear(); } e.clear(); for(int i=0;i\u003cm;i++){ int u,v,w; cin\u003e\u003ew\u003e\u003eu\u003e\u003ev; if(w){ g[u].push_back(v); in[v]++; }else e.push_back({u,v}); } if(!toposort()){ cout\u003c\u003c\"NO\"\u003c\u003cendl; return ; } for(int i=0;i\u003ctopo.size();i++)rk[topo[i]]=i; cout\u003c\u003c\"YES\"\u003c\u003cendl; for(int u=1;u\u003c=n;u++){ for(auto v:g[u])cout\u003c\u003cu\u003c\u003c\" \"\u003c\u003cv\u003c\u003cendl; } for(auto p:e){ if(rk[p.x]\u003crk[p.y])cout\u003c\u003cp.x\u003c\u003c\" \"\u003c\u003cp.y\u003c\u003cendl; else cout\u003c\u003cp.y\u003c\u003c\" \"\u003c\u003cp.x\u003c\u003cendl; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef pair\u003cint,int\u003e Pii; const int maxn=2e5+5; int n,m,rk[maxn]; vector\u003cPii\u003e e; void init(){} vector\u003cint\u003e g[maxn]; vector\u003cint\u003e topo; int in[maxn]; bool toposort(){ topo.clear(); for(int u=1;u\u003c=n;u++){ for(auto v:g[u])in[v]++; } int cnt=0; queue\u003cint\u003e q; for(int u=1;u\u003c=n;u++)if(!in[u])q.push(u); while(q.size()){ int u=q.front(); q.pop(); cnt++; topo.push_back(u); for(auto v:g[u])if(!--in[v])q.push(v); } return cnt==n; } inline void solve(){ cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++){ in[i]=0; g[i].clear(); } e.clear(); for(int i=0;i\u003cm;i++){ int u,v,w; cin\u003e\u003ew\u003e\u003eu\u003e\u003ev; if(w){ g[u].push_back(v); }else e.push_back({u,v}); } if(!toposort()){ cout\u003c\u003c\"NO\"\u003c\u003cendl; return ; } for(int i=0;i\u003ctopo.size();i++)rk[topo[i]]=i; cout\u003c\u003c\"YES\"\u003c\u003cendl; for(int u=1;u\u003c=n;u++){ for(auto v:g[u])cout\u003c\u003cu\u003c\u003c\" \"\u003c\u003cv\u003c\u003cendl; } for(auto p:e){ if(rk[p.x]\u003crk[p.y])cout\u003c\u003cp.x\u003c\u003c\" \"\u003c\u003cp.y\u003c\u003cendl; else cout\u003c\u003cp.y\u003c\u003c\" \"\u003c\u003cp.x\u003c\u003cendl; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:3","tags":["codeforces","topological sorting"],"title":"Codeforces1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"å°ç»“ å¾ˆä¹…æ²¡æœ‰åˆ·è¿‡å›¾è®ºï¼Œé€šè¿‡è¿™ä¸ªé¢˜ç®—æ˜¯å¤ä¹ äº†ä¸€ä¸‹æ‹“æ‰‘æ’åº ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:4","tags":["codeforces","topological sorting"],"title":"Codeforces1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"ä¼ é€é—¨ ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:0","tags":["codeforces","string hash"],"title":"Codeforces1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"é¢˜æ„ ç»™nä¸ªå­—ç¬¦ä¸²åˆå¹¶æˆä¸€ä¸ªä¸²å¹¶ä¸”åˆå¹¶æ—¶æ¶ˆé™¤åä¸€ä¸ªä¸²æœ€é•¿çš„ä¸å‰ä¸€ä¸ªä¸²åç¼€ç›¸åŒçš„å‰ç¼€ï¼Œå³abä¸bcåˆå¹¶ä¸ºabc ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:1","tags":["codeforces","string hash"],"title":"Codeforces1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"æ€è·¯ å°†å­—ç¬¦ä¸²hashä¹‹åæš´åŠ›å¯»æ‰¾æœ€é•¿çš„ç›¸åŒå‰åç¼€å³å¯ã€‚ç”±äºcodeforcesçš„æ•°æ®è¿˜æ˜¯æ¯”è¾ƒå¼ºçš„ï¼Œä¸ºäº†é˜²æ­¢hashç¢°æ’ï¼Œæœ‰ä¸¤ç§è§£å†³æ–¹æ³• åŒæ¨¡æ•°hash åœ¨æ‰¾åˆ°ç›¸åŒçš„hashå€¼ä¹‹åæš´åŠ›åˆ¤æ–­è¯¥å‰ç¼€å’Œè¯¥åç¼€æ˜¯å¦çœŸæ­£ç›¸åŒ ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:2","tags":["codeforces","string hash"],"title":"Codeforces1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"ä»£ç  #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef unsigned long long ull; typedef pair\u003cull,ull\u003e P; const int md1=998244353; const int md2=1e9+7; const ull B1=233,B2=131; const int maxn=1e6+5; int n,m; string t,s; vector\u003cP\u003e pre,ss,tt; void init(){ pre.push_back(P(1,1)); for(int i=1;i\u003cmaxn;i++)pre.push_back(P(pre[i-1].x*B1%md1,pre[i-1].y*B2%md2)); } inline void solve(){ cin\u003e\u003en; t.push_back('*'); tt.push_back(P(0,0)); while(cin\u003e\u003es){ ss.clear(); ss.push_back(P(0,0)); for(int i=1;i\u003c=s.size();i++)ss.push_back(P((ss[i-1].x*B1+s[i-1])%md1,(ss[i-1].y*B2+s[i-1])%md2)); int len=0; for(int i=min(t.size(),s.size());i\u003e0;i--){ if((tt[t.size()-1].x+md1-tt[t.size()-i-1].x*pre[i].x%md1)%md1==ss[i].x \u0026\u0026(tt[t.size()-1].y+md2-tt[t.size()-i-1].y*pre[i].y%md2)%md2==ss[i].y){ len=i; break; } } for(int i=len,j=t.size();i\u003cs.size();i++,j++){ t.push_back(s[i]); tt.push_back(P((tt[j-1].x*B1+s[i])%md1,(tt[j-1].y*B2+s[i])%md2)); } } for(int i=1;i\u003ct.size();i++)cout\u003c\u003ct[i]; cout\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; init(); while(__--){ solve(); } return 0; } #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef unsigned long long ull; const ull B=233; int n,m; string t,s; vector\u003cull\u003e pre,ss,tt; void init(){ pre.push_back(1); for(int i=1;i\u003cmaxn;i++)pre.push_back(pre[i-1]*B); } inline void solve(){ cin\u003e\u003en; t.push_back('*'); tt.push_back(0); while(cin\u003e\u003es){ ss.clear(); ss.push_back(0); for(int i=1;i\u003c=s.size();i++)ss.push_back(ss[i-1]*B+s[i-1]); int len=0; for(int i=min(t.size(),s.size());i\u003e0;i--){ if(tt[t.size()-1]-tt[t.size()-i-1]*pre[i]==ss[i]){ bool ok=1; for(int j=t.size()-i,k=0;j\u003ct.size()\u0026\u0026k\u003ci;j++,k++){ if(t[j]!=s[k]){ ok=0; break; } } if(ok){ len=i; break; } } } for(int i=len,j=t.size();i\u003cs.size();i++,j++){ t.push_back(s[i]); tt.push_back(tt[j-1]*B+s[i]); } } for(int i=1;i\u003ct.size();i++)cout\u003c\u003ct[i]; cout\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; init(); while(__--){ solve(); } return 0; } ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:3","tags":["codeforces","string hash"],"title":"Codeforces1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"å°ç»“ ä¸å¾—ä¸åæ§½Codeforcesçš„æ•°æ®å¤ªç‹ äº†ï¼ˆå¯æƒ³å½“æ—¶æ¯”èµ›çš„æ—¶å€™è¢«hackäº†å¤šå°‘äººï¼‰ï¼Œä¸»è¦æ³¨æ„çš„æ˜¯unsigned long long è‡ªç„¶æº¢å‡ºè¿™ç§hashæ–¹å¼è²Œä¼¼å¾ˆå®¹æ˜“è¢«å¡ ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:4","tags":["codeforces","string hash"],"title":"Codeforces1200E Compress Words","uri":"/posts/cf1200e/"}]