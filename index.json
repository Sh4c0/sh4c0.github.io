[{"categories":["2021/11"],"content":"传送门 ","date":"2021-11-09","objectID":"/posts/acwing1063/:0:0","tags":["acwing","Splay"],"title":"Acwing 1063 永无乡","uri":"/posts/acwing1063/"},{"categories":["2021/11"],"content":"题意 给出$n$个岛，每个岛有权值$a[i]$，两种操作： 连接两座岛 询问岛$x$所在的联通块中权值第$k$小的岛的编号 ","date":"2021-11-09","objectID":"/posts/acwing1063/:0:1","tags":["acwing","Splay"],"title":"Acwing 1063 永无乡","uri":"/posts/acwing1063/"},{"categories":["2021/11"],"content":"思路 首先开$n$棵Splay，在结点中记录该结点归属于哪一棵Splay的信息$bl$，然后启发式合并Splay（把结点数小的Splay中的结点插入到大的Splay中），显然这样操作最后的复杂度是$O(nlognlog)$（说白了我也不会证） ","date":"2021-11-09","objectID":"/posts/acwing1063/:0:2","tags":["acwing","Splay"],"title":"Acwing 1063 永无乡","uri":"/posts/acwing1063/"},{"categories":["2021/11"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' const int maxn=2e5+5; int n,m,q; char opt[3]; int a[maxn]; struct node{ int ch[2],fa,size,bl; int val; }tree[maxn]; int root[maxn]; inline void pushup(int u){ tree[u].size=tree[tree[u].ch[0]].size+tree[tree[u].ch[1]].size+1; } inline void rotate(int x){ int y=tree[x].fa,z=tree[y].fa; int k=tree[y].ch[1]==x; tree[z].ch[tree[z].ch[1]==y]=x,tree[x].fa=z; tree[y].ch[k]=tree[x].ch[k^1],tree[tree[x].ch[k^1]].fa=y; tree[x].ch[k^1]=y,tree[y].fa=x; pushup(y),pushup(x); } void splay(int x,int k,int tr){ while(tree[x].fa!=k){ int y=tree[x].fa,z=tree[y].fa; if(z!=k){ if((tree[y].ch[1]==x)^(tree[z].ch[1]==y))rotate(x); else rotate(y); } rotate(x); } if(!k)root[tr]=x; } void insert(int u,int tr){ int fa=0,v=root[tr]; while(v)fa=v,v=tree[v].ch[tree[u].val\u003etree[v].val]; if(fa)tree[fa].ch[tree[u].val\u003etree[fa].val]=u; tree[u].ch[0]=tree[u].ch[1]=0; tree[u].fa=fa; tree[u].size=1; tree[u].bl=tr; splay(u,0,tr); } void dfs(int u,int tr){ if(tree[u].ch[0])dfs(tree[u].ch[0],tr); if(tree[u].ch[1])dfs(tree[u].ch[1],tr); insert(u,tr); } void init(int n){ for(int i=1;i\u003c=n;i++){ root[i]=i; tree[i].size=1; tree[i].val=a[i]; tree[i].bl=i; } } void merge(int u,int v){ int x=tree[u].bl,y=tree[v].bl; if(x==y)return ; tree[root[x]].size\u003ctree[root[y]].size?(dfs(root[x],y),root[x]=0):(dfs(root[y],x),root[y]=0); } int get_k(int u,int rnk){ while(1){ if(tree[tree[u].ch[0]].size\u003e=rnk)u=tree[u].ch[0]; else if(tree[tree[u].ch[0]].size+1==rnk)return u; else rnk-=tree[tree[u].ch[0]].size+1,u=tree[u].ch[1]; } } inline void solve(){ int u,v; scanf(\"%d %d\",\u0026n,\u0026m); for(int i=1;i\u003c=n;i++)scanf(\"%d\",\u0026a[i]); init(n); while(m--){ scanf(\"%d %d\",\u0026u,\u0026v); merge(u,v); } scanf(\"%d\",\u0026q); while(q--){ scanf(\"%s %d %d\",\u0026opt,\u0026u,\u0026v); if(opt[0]=='B')merge(u,v); else{ if(tree[root[tree[u].bl]].size\u003cv)puts(\"-1\"); else printf(\"%d\\n\",get_k(root[tree[u].bl],v)); } } } int main(){ int __=1; while(__--){ solve(); } return 0; } ","date":"2021-11-09","objectID":"/posts/acwing1063/:0:3","tags":["acwing","Splay"],"title":"Acwing 1063 永无乡","uri":"/posts/acwing1063/"},{"categories":["2021/11"],"content":"小结 思路几乎是看完题就想到了，实现的过程真是一言难尽，各种小错误不断，从dfs插入的顺序不对，到递归版查找第$k$大没有返回值，然后到Splay的旋转向上更新写反，每一个错误都是很不应该的，修bug足足修了两天，实在是对自己的状态担忧 ","date":"2021-11-09","objectID":"/posts/acwing1063/:0:4","tags":["acwing","Splay"],"title":"Acwing 1063 永无乡","uri":"/posts/acwing1063/"},{"categories":["2021/11"],"content":"计划 树套树初步学习 掌握AC自动机上DP、fail树 树链剖分初步学习 Splay收尾 看y总Linux基础课1 看y总Django框架课1 西瓜书前五章作业 ","date":"2021-11-08","objectID":"/posts/plan1/:0:1","tags":["plan"],"title":"PLAN 2021.11.8-2021.11.14","uri":"/posts/plan1/"},{"categories":["2021/11"],"content":"总结 最近感觉自己学习效率过于低了（懒得令人发指），所以决定从这周开始好好计划一下学习任务，第一次计划，也不知道最后会完成的怎么样（笑），就这样吧 ","date":"2021-11-08","objectID":"/posts/plan1/:0:2","tags":["plan"],"title":"PLAN 2021.11.8-2021.11.14","uri":"/posts/plan1/"},{"categories":["2021/10"],"content":"传送门 ","date":"2021-10-27","objectID":"/posts/cf1582e/:0:0","tags":["codeforces","dp"],"title":"Codeforces 1582E Pchelyonok and Segments","uri":"/posts/cf1582e/"},{"categories":["2021/10"],"content":"题意 将一个数组划分成$k$个子段，对于第$i$个子段和第$i+1$个子段，需要满足子段$i$的元素个数为$n-i+1$，子段$n-(i+1)+1$的元素个数为$i+1$，并且子段$i$的元素之和小于子段$i+1$的元素之和，输出$k$的最大值 ","date":"2021-10-27","objectID":"/posts/cf1582e/:0:1","tags":["codeforces","dp"],"title":"Codeforces 1582E Pchelyonok and Segments","uri":"/posts/cf1582e/"},{"categories":["2021/10"],"content":"思路 首先不难看出长度为$n$的数组，$k$的取值满足$(k+1)*k/2\\leqslant n$ 我们将整个数组倒置，此时第$i$个子段的长度为$i$，同时预处理出前缀和$pre$ 我们令$dp[i][j]$代表前$i$个元素中，子段数量为$k$的情况中的第$k$个子段的最大值，如果不可能则为$0$ 所以状态转移方程如下： $dp[i][j]=dp[i-1][j]$ 当$pre[i]-pre[i-j]$或者$j=1$时,$dp[i][j]=max(dp[i][j],pre[i]-pre[i-j])$ ","date":"2021-10-27","objectID":"/posts/cf1582e/:0:2","tags":["codeforces","dp"],"title":"Codeforces 1582E Pchelyonok and Segments","uri":"/posts/cf1582e/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; typedef long long ll; const int maxn=1e5+5; const int maxm=450; int n,m; int a[maxn]; ll pre[maxn],st[maxn]; ll dp[maxn][maxm]; void init(){ for(int i=1;i\u003c=500;i++)st[i]=st[i-1]+i; } ll sub(int l,int r){ return pre[r]-pre[l-1]; } inline void solve(){ cin\u003e\u003en; m= upper_bound(st,st+500,n)-st-1; for(int i=n;i\u003e0;i--)cin\u003e\u003ea[i]; for(int i=1;i\u003c=n;i++)pre[i]=pre[i-1]+a[i]; for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=m;j++){ if(i\u003cst[j])dp[i][j]=0; else{ dp[i][j]=dp[i-1][j]; if(j==1||sub(i-j+1,i)\u003cdp[i-j][j-1])dp[i][j]=max(dp[i][j],sub(i-j+1,i)); } } } for(int i=m;i\u003e0;i--){ if(dp[n][i]!=0){ cout\u003c\u003ci\u003c\u003cendl; return ; } } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; init(); while(__--){ solve(); } return 0; } ","date":"2021-10-27","objectID":"/posts/cf1582e/:0:3","tags":["codeforces","dp"],"title":"Codeforces 1582E Pchelyonok and Segments","uri":"/posts/cf1582e/"},{"categories":["2021/10"],"content":"小结 dp苦手，大大小小的bug改了一天 ","date":"2021-10-27","objectID":"/posts/cf1582e/:0:4","tags":["codeforces","dp"],"title":"Codeforces 1582E Pchelyonok and Segments","uri":"/posts/cf1582e/"},{"categories":["2021/10"],"content":"传送门 ","date":"2021-10-26","objectID":"/posts/cf1602d/:0:0","tags":["codeforces","bfs"],"title":"Codeforces 1602D Frog Traveler","uri":"/posts/cf1602d/"},{"categories":["2021/10"],"content":"题意 一只青蛙在井底初始位置为$n$，想跳到地面（地面为$0$），当青蛙在$i$时，可以向上跳$0～a[i]$任意高度，当青蛙跳到位置$j$时，会向下滑$b[i]$，求跳至地面最少需要几步，并输出路径 ","date":"2021-10-26","objectID":"/posts/cf1602d/:0:1","tags":["codeforces","bfs"],"title":"Codeforces 1602D Frog Traveler","uri":"/posts/cf1602d/"},{"categories":["2021/10"],"content":"思路 显然当青蛙想去往位置$j$时，其必须去到位置$i$，位置$i$满足$i+b[i]=j$，可以建立两个数组，$hua[i]=j$，$yuan[j]=i$，在bfs中我们只考虑最后滑到的位置 首先我们考虑裸bfs，对于位置$i$可以到达$hua[i-a[i],i-a[i]+1…i-1,i]$，由于边权相等，所以最短路中每一个点最多只会被访问一次 但是当我们以这种方式bfs时，对于位置$i$和位置$j$，$hua[max(i-a[i],j-a[j])…min(i,j)]$会被重复判断，因此我们在bfs的过程中记录位置$r$为我们以经访问过的最小的访问过的值，即对于位置$i$我们只需要判断$hua[i-a[i],r]$，然后更新$r=min(r,i-a[i]-1)$ ","date":"2021-10-26","objectID":"/posts/cf1602d/:0:2","tags":["codeforces","bfs"],"title":"Codeforces 1602D Frog Traveler","uri":"/posts/cf1602d/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=3e5+5; int n,m; int a[maxn],b[maxn]; int fa[maxn]; int hua[maxn]; int yuan[maxn]; bool vis[maxn]; vector\u003cint\u003e ans; inline void solve(){ scanf(\"%d\",\u0026n); n++; hua[n]=n; for(int i=2;i\u003c=n;i++)scanf(\"%d\",\u0026a[i]); for(int i=2;i\u003c=n;i++)scanf(\"%d\",\u0026b[i]); queue\u003cint\u003e q; fa[1]=-1; fa[n]=n; yuan[n]=n; hua[n]=n; vis[n]=1; q.push(n); int r=n-1; while(q.size()){ int t=q.front(); q.pop(); int l=t-a[t]; for(int i=l;i\u003c=r;i++){ int p=i+b[i]; if(vis[p])continue; fa[p]=t; hua[i]=p; yuan[p]=i; vis[p]=1; q.push(p); } if(l\u003c=r)r=l-1; } if(fa[1]==-1){ puts(\"-1\"); return ; } int p=1; while(p!=n){ ans.push_back(p); p=hua[p]; p=fa[p]; p=yuan[p]; } printf(\"%d\\n\",(int)ans.size()); for(int i=(int)ans.size()-1;i\u003e=0;i--)printf(\"%d \",ans[i]-1); puts(\"\"); } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-26","objectID":"/posts/cf1602d/:0:3","tags":["codeforces","bfs"],"title":"Codeforces 1602D Frog Traveler","uri":"/posts/cf1602d/"},{"categories":["2021/10"],"content":"总结 很简单的题，但是打比赛的时候一度想到线段树优化建图，还是没有更多的从剪枝、思维的角度想问题 ","date":"2021-10-26","objectID":"/posts/cf1602d/:0:4","tags":["codeforces","bfs"],"title":"Codeforces 1602D Frog Traveler","uri":"/posts/cf1602d/"},{"categories":["2021/10"],"content":"传送门 ","date":"2021-10-21","objectID":"/posts/cf438d/:0:0","tags":["codeforces","segment tree"],"title":"Codeforces 438D The Child and Sequence","uri":"/posts/cf438d/"},{"categories":["2021/10"],"content":"题意 构造一种数据结构满足以下三种操作 输出区间$[l,r]$所有元素的和 区间$[l,r]$中所有元素对$x$取模 将元素$a[i]$赋值$x$ ","date":"2021-10-21","objectID":"/posts/cf438d/:0:1","tags":["codeforces","segment tree"],"title":"Codeforces 438D The Child and Sequence","uri":"/posts/cf438d/"},{"categories":["2021/10"],"content":"思路 首先不难看出这是一个线段树 这里主要讨论第二种操作，对任意一个元素$a[i]$，如果$x\u003ea[i]$，则操作无意义。显然如果操作对$a[i]$有意义，则该操作会使得$a[i]$减半。所以$a[i]$最多修改$\\log a[i]$次，由此可见忽略无效操作然后暴力更新即可。 ","date":"2021-10-21","objectID":"/posts/cf438d/:0:2","tags":["codeforces","segment tree"],"title":"Codeforces 438D The Child and Sequence","uri":"/posts/cf438d/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; typedef long long ll; const int maxn=2e5+5; int n,m; int a[maxn]; struct node{ int l,r; ll mx,sum; }tree[maxn\u003c\u003c2]; void pushup(int p){ tree[p].sum=tree[p\u003c\u003c1].sum+tree[p\u003c\u003c1|1].sum; tree[p].mx=max(tree[p\u003c\u003c1].mx,tree[p\u003c\u003c1|1].mx); } void build(int l,int r,int p=1){ tree[p].l=l,tree[p].r=r; if(l==r){ tree[p].sum=tree[p].mx=a[l]; return ; } int mid=(tree[p].l+tree[p].r)\u003e\u003e1; build(l,mid,p\u003c\u003c1); build(mid+1,r,p\u003c\u003c1|1); pushup(p); } void Mod(int l,int r,int md,int p=1){ if(tree[p].mx\u003cmd)return ; if(tree[p].l==tree[p].r){ tree[p].mx%=md; tree[p].sum=tree[p].mx; return ; } int mid=(tree[p].l+tree[p].r)\u003e\u003e1; if(l\u003c=mid\u0026\u0026tree[p\u003c\u003c1].mx\u003e=md)Mod(l,r,md,p\u003c\u003c1); if(r\u003emid\u0026\u0026tree[p\u003c\u003c1|1].mx\u003e=md)Mod(l,r,md,p\u003c\u003c1|1); pushup(p); } void Set(int k,int val,int p=1){ if(tree[p].l==tree[p].r){ tree[p].mx=val; tree[p].sum=val; return ; } int mid=(tree[p].l+tree[p].r)\u003e\u003e1; if(k\u003c=mid)Set(k,val,p\u003c\u003c1); else Set(k,val,p\u003c\u003c1|1); pushup(p); } ll query(int l,int r,int p=1){ if(tree[p].l\u003e=l\u0026\u0026tree[p].r\u003c=r)return tree[p].sum; int mid=(tree[p].l+tree[p].r)\u003e\u003e1; ll sum=0; if(l\u003c=mid)sum+=query(l,r,p\u003c\u003c1); if(r\u003emid)sum+=query(l,r,p\u003c\u003c1|1); return sum; } inline void solve(){ cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++)cin\u003e\u003ea[i]; build(1,n); int opt; int u,v,w; while(m--){ cin\u003e\u003eopt; if(opt==1){ cin\u003e\u003eu\u003e\u003ev; cout\u003c\u003cquery(u,v)\u003c\u003cendl; }else if(opt==2){ cin\u003e\u003eu\u003e\u003ev\u003e\u003ew; if(w\u003c=tree[1].mx)Mod(u,v,w); }else{ cin\u003e\u003eu\u003e\u003ev; Set(u,v); } } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-21","objectID":"/posts/cf438d/:0:3","tags":["codeforces","segment tree"],"title":"Codeforces 438D The Child and Sequence","uri":"/posts/cf438d/"},{"categories":["2021/10"],"content":"小结 势能线段树的简单应用 ","date":"2021-10-21","objectID":"/posts/cf438d/:0:4","tags":["codeforces","segment tree"],"title":"Codeforces 438D The Child and Sequence","uri":"/posts/cf438d/"},{"categories":["2021/10"],"content":"传送门 ","date":"2021-10-13","objectID":"/posts/cf1042d/:0:0","tags":["codeforces","segment tree"],"title":"Codeforces 1042D Petya and Array","uri":"/posts/cf1042d/"},{"categories":["2021/10"],"content":"题意 输出一个数组中有多少连续的子序列之和小于$m$ ","date":"2021-10-13","objectID":"/posts/cf1042d/:0:1","tags":["codeforces","segment tree"],"title":"Codeforces 1042D Petya and Array","uri":"/posts/cf1042d/"},{"categories":["2021/10"],"content":"思路 先计算出前缀和，显然我们需要找出满足$sum_r-sum_l\u003ct$的两个下标，可以转化为$sum_r-t\u003csum_l$ 然后建立前缀和的权值线段树，并在修改前查询对于当前点$r$，有多少大于$sum_r+t$的点，求和即可 另外此题需要离散化 ","date":"2021-10-13","objectID":"/posts/cf1042d/:0:2","tags":["codeforces","segment tree"],"title":"Codeforces 1042D Petya and Array","uri":"/posts/cf1042d/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; typedef long long ll; const int maxn=4e5+5; ll n,m; ll a[maxn],num[maxn]; struct node{ int l,r; ll val; }tree[maxn\u003c\u003c2]; vector\u003cll\u003e v; inline int getid(ll x){ return lower_bound(v.begin(),v.end(),x)-v.begin()+1;}; void discrete(){ sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end()); } void build(int l,int r,int o=1){ tree[o].l=l,tree[o].r=r; tree[o].val=0; if(tree[o].l==tree[o].r)return ; int mid=(tree[o].l+tree[o].r)\u003e\u003e1; build(l,mid,o\u003c\u003c1); build(mid+1,r,o\u003c\u003c1|1); } void pushup(int o){ tree[o].val=tree[o\u003c\u003c1].val+tree[o\u003c\u003c1|1].val; } void change(int lr,int o=1){ if(tree[o].l==tree[o].r){ tree[o].val++; return ; } int mid=(tree[o].l+tree[o].r)\u003e\u003e1; if(lr\u003c=mid)change(lr,o\u003c\u003c1); else change(lr,o\u003c\u003c1|1); pushup(o); } ll query(int l,int r,int o=1){ if(l\u003c=tree[o].l\u0026\u0026r\u003e=tree[o].r)return tree[o].val; int mid=(tree[o].l+tree[o].r)\u003e\u003e1; ll sum=0; if(l\u003c=mid)sum+=query(l,r,o\u003c\u003c1); if(r\u003emid)sum+=query(l,r,o\u003c\u003c1|1); return sum; } inline void solve(){ cin\u003e\u003en\u003e\u003em; v.push_back(0); for(int i=1;i\u003c=n;i++){ cin\u003e\u003ea[i]; a[i]+=a[i-1]; v.push_back(a[i]); } for(int i=1;i\u003c=n;i++)v.push_back(a[i]-m+1); discrete(); for(int i=1;i\u003c=n;i++)num[i]=getid(a[i]); build(1,v.size()); change(getid(0)); ll ans=0; for(int i=1;i\u003c=n;i++){ int tmp=query(getid(a[i]-m+1),v.size()); ans+=tmp; change(num[i]); } cout\u003c\u003cans\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-13","objectID":"/posts/cf1042d/:0:3","tags":["codeforces","segment tree"],"title":"Codeforces 1042D Petya and Array","uri":"/posts/cf1042d/"},{"categories":["2021/10"],"content":"小结 权值线段树和前缀和的简单应用，码量有点大，细节出错找bug还是找了很久 ","date":"2021-10-13","objectID":"/posts/cf1042d/:0:4","tags":["codeforces","segment tree"],"title":"Codeforces 1042D Petya and Array","uri":"/posts/cf1042d/"},{"categories":["2021/10"],"content":"传送门 step1 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:0:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"A. Suffix Array - 1 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:1:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 求后缀数组 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:1:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 直接上板子 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:1:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=1e5+5; const int maxm=1e9; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i],tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } char tmp[maxn]; inline void solve(){ cin\u003e\u003e(tmp+1); n=strlen(tmp+1); for(int i=1;i\u003c=n;i++)s[i]=tmp[i]; s[n+1]='$'; SuffixArray(); for(int i=1;i\u003c=N;i++)cout\u003c\u003csa[i]-1\u003c\u003c\" \"; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } step2 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:1:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"A. Suffix Array - 2 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:2:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 更快的求后缀数组 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:2:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 同样直接上板子 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:2:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=1e5+5; const int maxm=1e9; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i],tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } char tmp[maxn]; inline void solve(){ cin\u003e\u003e(tmp+1); n=strlen(tmp+1); for(int i=1;i\u003c=n;i++)s[i]=tmp[i]; s[n+1]='$'; SuffixArray(); for(int i=1;i\u003c=N;i++)cout\u003c\u003csa[i]-1\u003c\u003c\" \"; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } step3 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:2:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"A. Substring Search ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:3:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 给定字符串$t$，$n$次询问，给定字符串$s_i$是否为$t$的子串 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:3:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 得出后缀数组之后，在后缀数组中二分查找即可 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:3:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=3e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i],tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } char tmp[maxn]; int len; bool check(int x){ x=sa[x]; for(int i=0;i\u003cmin(len,N-x+1);i++){ if(s[x+i]\u003etmp[i+1])return 1; else if(s[x+i]\u003ctmp[i+1])return 0; } return len\u003c=N-x+1; } int bsearch_1(int l,int r){ len=strlen(tmp+1); while(l\u003cr){ int mid=(l+r)\u003e\u003e1; if(check(mid))r=mid; else l=mid+1; } l=sa[l]; if(len\u003eN-l+1)return 0; for(int i=0;i\u003cmin(len,N-l+1);i++){ if(s[l+i]!=tmp[i+1]){ return 0; } } return 1; } inline void solve(){ cin\u003e\u003e(s+1)\u003e\u003en; SuffixArray(); for(int i=1;i\u003c=n;i++){ cin\u003e\u003e(tmp+1); if(bsearch_1(1,N))cout\u003c\u003c\"Yes\"\u003c\u003cendl; else cout\u003c\u003c\"No\"\u003c\u003cendl; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:3:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"B. Counting Substrings ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:4:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 给定字符串$t$，$n$次询问，给定字符串$s_i$在$t$中出现的次数 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:4:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 二分查找找出第一个字典序比$s_i$小的和第一个比$s_i$大的即可 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:4:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=3e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i],tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } char tmp[maxn]; int len; bool check1(int x){ string a(tmp+1),b; x=sa[x]; for(int i=0;i\u003cmin(N-x+1,len);i++)b.push_back(s[x+i]); return b\u003e=a; } int bsearch_1(int l,int r){ while(l\u003cr){ int mid=(l+r)\u003e\u003e1; if(check1(mid))r=mid; else l=mid+1; } return l; } bool check2(int x){ string a(tmp+1),b; x=sa[x]; for(int i=0;i\u003cmin(N-x+1,len);i++)b.push_back(s[x+i]); return b\u003ea; } int bsearch_2(int l,int r){ while(l\u003cr){ int mid=(l+r+1)\u003e\u003e1; if(check2(mid))r=mid-1; else l=mid; } return l; } inline void solve(){ cin\u003e\u003e(s+1)\u003e\u003en; SuffixArray(); for(int i=1;i\u003c=n;i++){ cin\u003e\u003e(tmp+1); len=strlen(tmp+1); int ans1=bsearch_2(1,N),ans2=bsearch_1(1,N); string a(tmp+1),b; for(int i=0;i\u003cmin(N-sa[ans2]+1,len);i++)b.push_back(s[sa[ans2]+i]); if(a!=b)cout\u003c\u003c0\u003c\u003cendl; else cout\u003c\u003cans1-ans2+1\u003c\u003cendl; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } step4 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:4:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"A. Suffix Array and LCP ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:5:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 求后缀数组以及$height$数组 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:5:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 直接上板子 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:5:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=3e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } inline void solve(){ string str; cin\u003e\u003estr; str.push_back('$'); for(int i=0;i\u003cstr.size();i++)s[i+1]=str[i]; SuffixArray(); for(int i=1;i\u003c=N;i++)cout\u003c\u003csa[i]-1\u003c\u003c\" \"; cout\u003c\u003cendl; Height(); for(int i=2;i\u003c=N;i++)cout\u003c\u003cht[i]\u003c\u003c\" \"; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } step5 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:5:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"A. Number of Different Substrings ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:6:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 对于给定字符串$s$，求出其不同子串的数量 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:6:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 对于后缀$sa[i]$和后缀$sa[i+1]$，后缀$sa[i+1]$的贡献为其长度减去与后缀$sa[i]$部分，所以不同子串的数量为$n(n-1)/2-\\sum_{i=1}^n height[i]$ ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:6:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; typedef long long ll; const int maxn=4e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=75; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]-'0'+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } inline void solve(){ cin\u003e\u003e(s+1); SuffixArray(); Height(); ll ans=0; for(int i=1;i\u003c=N;i++)ans+=(ll)sa[i]-ht[i]; cout\u003c\u003cans\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:6:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"B. Longest Common Substring ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:7:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 给定字符串$s$和$t$，输出其最长公共子串 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:7:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 首先将两个字符串拼接在一起用$分隔 很容易想到两个字符串中以最长公共子串味首的后缀在后缀数组中必然相邻，所以在$height$数组中找出两个后缀来自不同的字符串且值最大的位置即可 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:7:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=4e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } inline void solve(){ string s1,s2; cin\u003e\u003es1\u003e\u003es2; int len1=s1.size(),len2=s2.size(); s1+='$'; s1+=s2; for(int i=0;i\u003cs1.size();i++)s[i+1]=s1[i]; SuffixArray(); Height(); int ans=1; for(int i=2;i\u003c=N;i++){ if(sa[i]\u003c=len1\u0026\u0026sa[i-1]\u003elen1+1\u0026\u0026ht[ans]\u003cht[i])ans=i; if(sa[i-1]\u003c=len1\u0026\u0026sa[i]\u003elen1+1\u0026\u0026ht[ans]\u003cht[i])ans=i; } for(int i=0;i\u003cht[ans];i++)cout\u003c\u003cs[sa[ans]+i]; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:7:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"C. Sorting Substrings ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:8:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 给定字符串$s$以及其$n$个子串，将其排序后输出（子串均以$l,r$的方式给出以及输出） ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:8:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 对于子串$[l_i,r_i]$和$[l_j,r_j]$，当$lcp(l_i,l_j) \\geqslant min(r_i-l_i+1,r_j-l_j+1)$，则只需要比较其长度即可，否则则比较$rank[l_i]$和$rank[l_j]$ ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:8:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define x first #define y second typedef pair\u003cint,int\u003e P; const int maxn=4e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } int st[maxn][30],plg[maxn]; void ST_pre(){ plg[1]=0; for(int i=2;i\u003c=N;i++)plg[i]=plg[i/2]+1; for(int i=1;i\u003c=N;i++)st[i][0]=ht[i]; for(int j=1;j\u003c=plg[N];j++){ for(int i=1;i\u003c=N-(1\u003c\u003cj)+1;i++){ st[i][j]=min(st[i][j-1],st[i+(1\u003c\u003c(j-1))][j-1]); } } } int ST_query(int l,int r){ int k=plg[r-l+1]; return min(st[l][k],st[r-(1\u003c\u003ck)+1][k]); } int lcp(int a,int b){//第a个后缀与第b个后缀的最长公共前缀 a=rk[a],b=rk[b]; if(a\u003eb)swap(a,b); return ST_query(a+1,b); } vector\u003cP\u003e v; bool f(P a,P b){ int lena=a.y-a.x+1; int lenb=b.y-b.x+1; int len=lcp(a.x,b.x); if(a.x==b.x)len=inf; if(len\u003e=min(lena,lenb)){ if(lena\u003clenb)return 1; else if(lena\u003elenb)return 0; else if(a.x\u003cb.x)return 1; else if(a.x\u003eb.x)return 0; else return a.y\u003cb.y; } return rk[a.x]\u003crk[b.x]; } inline void solve(){ cin\u003e\u003e(s+1); SuffixArray(); Height(); ST_pre(); cin\u003e\u003en; int a,b; for(int i=0;i\u003cn;i++){ cin\u003e\u003ea\u003e\u003eb; v.push_back(P(a,b)); } sort(v.begin(),v.end(),f); for(int i=0;i\u003cn;i++)cout\u003c\u003cv[i].x\u003c\u003c\" \"\u003c\u003cv[i].y\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:8:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"D. Borders ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:9:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 如果一个字符串同时是另一个字符串的前缀和后缀，则称这个字符串为另一个字符串的$border$ 对于给定串$s$，输出其所有子串的$border$数量之和 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:9:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 对于后缀$i$和后缀$j$这对后缀的贡献为$lcp(i,j)$，因此答案为$\\sum_{i=1}^n \\sum_{j=i}^nlcp(i,j)$ 而$lcp(i,j)$本质为$min{height[i+1…j]}$ 因此问题变成了求height数组的子数组最小值之和，用单调栈和dp优化这个过程 构造递增的单调栈，定义$sum[i]$为以$i$为右端点的区间最小值之和，对于$i$我们找到第一个比$i$小的位置$j$，$sum[i]$由两部分构成，左端点在$j$的右侧的子数组之和为$(i-j)*height[i]$，而左端点在$j$的左侧的字数组之和为$sum[j]$，所以$sum[i]=(i-j)*height[i]+sum[j]$ ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:9:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; typedef long long ll; const int maxn=4e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } stack\u003cint\u003e st; ll sum[maxn]; inline void solve(){ cin\u003e\u003e(s+1); SuffixArray(); Height(); ll ans=0; for(int i=1;i\u003c=N;i++)ans+=i; for(ll i=2;i\u003c=N;i++){ while(!st.empty()\u0026\u0026ht[st.top()]\u003e=ht[i])st.pop(); sum[i]=st.empty()?(i-1)*ht[i]:(i-st.top())*ht[i]+sum[st.top()]; st.push(i); } for(int i=2;i\u003c=N;i++)ans+=sum[i]; cout\u003c\u003cans\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:9:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"E. Refrain ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:10:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 对给定字符串$s$，找到子串$t$，$t$满足出现次数与字符串长度的乘积在所有子串中最大 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:10:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 对于任意子串为首的后缀其在后缀数组中出现都是连续的，该问题可以化简为在$height$数组中求最大矩形 利用单调栈找出对于任意$height[i]$左侧和右侧第一个比$height[i]$小的位置记为$pre[i]$和$nxt[i]$，$height[i]*(nxt[i]-pre[i])$即为以$height[i]$为高宽度最宽的矩形，求出最值即可 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:10:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; typedef long long ll; const int maxn=4e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } stack\u003cint\u003e st; ll pre[maxn],nxt[maxn]; inline void solve(){ cin\u003e\u003en\u003e\u003em; int c; string ss; for(int i=1;i\u003c=n;i++){ cin\u003e\u003ec; s[i]='a'+c; } SuffixArray(); Height(); ll ans=N; for(int i=2;i\u003c=N;i++){ while(st.size()\u0026\u0026ht[i]\u003c=ht[st.top()])st.pop(); pre[i]=st.size()?st.top():1; st.push(i); } while(st.size())st.pop(); for(int i=N;i\u003e=2;i--){ while(st.size()\u0026\u0026ht[i]\u003c=ht[st.top()])st.pop(); nxt[i]=st.size()?st.top():N+1; st.push(i); } int len=0,id=0; for(int i=2;i\u003c=N;i++){ if((nxt[i]-pre[i])*ht[i]\u003eans||((nxt[i]-pre[i])*ht[i]==ans\u0026\u0026(nxt[i]-pre[i])\u003clen)){ ans=(nxt[i]-pre[i])*ht[i]; len=nxt[i]-pre[i]; id=i; } } if(ans==N){ cout\u003c\u003cN\u003c\u003cendl; cout\u003c\u003cN\u003c\u003cendl; for(int i=1;i\u003c=N;i++)cout\u003c\u003cs[i]-'a'\u003c\u003c\" \"; return ; } cout\u003c\u003cans\u003c\u003cendl; cout\u003c\u003cans/len\u003c\u003cendl; for(int i=0;i\u003cans/len;i++)cout\u003c\u003cs[sa[id]+i]-'a'\u003c\u003c\" \"; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:10:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"F. Periodic Substring ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:11:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 求出重复次数最多的连续子串 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:11:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 枚举子串长度为$i$，如果子串中循环节重复次数不少于两次，那么字符$s[0],s[i],s[2i],s[3i]…$必然会有两个或两个以上出现在该子串中，不妨设前两个字符为$s[j],s[j+i]$，我们记$lcp(j,j+i)$为$cnt$我们考虑两种情况 如果$s[j]$是子串的首字符，那么该子串的循环节重复次数为$cnt/i$，此时子串为$s[j…j+i+cnt-cnt%i]$ 否则，$s[j]$左侧的$i-cnt%i$个字符有可能可以继续拼凑出一个循环节，我们记此时的起点$j-(i-cnt%i)$为$k$，当$lcp(k,k+i) \\geqslant i$则可以拼凑，此时子串为$s[k…j+i+cnt]$ ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:11:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=4e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=75; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]-'0'+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } int st[maxn][30],plg[maxn]; void ST_pre(){ plg[1]=0; for(int i=2;i\u003c=N;i++)plg[i]=plg[i/2]+1; for(int i=1;i\u003c=N;i++)st[i][0]=ht[i]; for(int j=1;j\u003c=plg[N];j++){ for(int i=1;i\u003c=N-(1\u003c\u003cj)+1;i++){ st[i][j]=min(st[i][j-1],st[i+(1\u003c\u003c(j-1))][j-1]); } } } int ST_query(int l,int r){ int k=plg[r-l+1]; return min(st[l][k],st[r-(1\u003c\u003ck)+1][k]); } int lcp(int a,int b){//第a个后缀与第b个后缀的最长公共前缀 a=rk[a],b=rk[b]; if(a\u003eb)swap(a,b); return ST_query(a+1,b); } inline void solve(){ cin\u003e\u003e(s+1); SuffixArray(); Height(); ST_pre(); int ans=1; for(int i=1;i\u003c=N;i++){ for(int j=1;j+i\u003c=N;j+=i){ int cnt=lcp(j,j+i); int k=j-(i-cnt%i); cnt=cnt/i+1; if(k\u003e=1\u0026\u0026lcp(k,k+i)\u003e=i)cnt++; ans=max(cnt,ans); } } cout\u003c\u003cans\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } 小结 通过这么多题算是对后缀数组有了一个初步的了解，感叹一下还是自己会的东西太少了，在做与单调栈结合的题目费了很大的功夫 后缀数组的学习到这里算是告一段落了 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:11:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/8"],"content":"传送门 ","date":"2021-08-28","objectID":"/posts/cf126b/:0:0","tags":["codeforces","KMP"],"title":"Codeforces 126B Password","uri":"/posts/cf126b/"},{"categories":["2021/8"],"content":"题意 给一个字符串$S$，找到最长的字符串$T$同时为$S$的前缀、后缀且作为非前后缀出现在字符串中 ","date":"2021-08-28","objectID":"/posts/cf126b/:0:1","tags":["codeforces","KMP"],"title":"Codeforces 126B Password","uri":"/posts/cf126b/"},{"categories":["2021/8"],"content":"思路 利用next数组求出串$S$所有相同的前后缀，然后遍历next数组查找出现的最长的且与上一步求得的相同的前后缀的相同子串即可 ","date":"2021-08-28","objectID":"/posts/cf126b/:0:2","tags":["codeforces","KMP"],"title":"Codeforces 126B Password","uri":"/posts/cf126b/"},{"categories":["2021/8"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' const int maxn=1e6+5; string s; int nxt[maxn]; void kmp_pre(string s,int* nxt){ int i,j; j=nxt[0]=-1; i=0; while(i\u003cs.size()){ while(j!=-1\u0026\u0026s[i]!=s[j])j=nxt[j]; nxt[++i]=++j; } } inline void solve(){ cin\u003e\u003es; kmp_pre(s,nxt); map\u003cint,int\u003e mp; int t=nxt[s.size()]; while(t!=-1){ mp[t]=1; t=nxt[t]; } int ans=0; for(int i=2;i\u003cs.size();i++){ if(mp[nxt[i]])ans=max(ans,nxt[i]); } if(ans){ for(int i=0;i\u003cans;i++)cout\u003c\u003cs[i]; cout\u003c\u003cendl; }else cout\u003c\u003c\"Just a legend\"\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-08-28","objectID":"/posts/cf126b/:0:3","tags":["codeforces","KMP"],"title":"Codeforces 126B Password","uri":"/posts/cf126b/"},{"categories":["2021/8"],"content":"小结 搁置了很久的一道题，对next数组的简单应用，今天看了一下直接秒掉了 ","date":"2021-08-28","objectID":"/posts/cf126b/:0:4","tags":["codeforces","KMP"],"title":"Codeforces 126B Password","uri":"/posts/cf126b/"},{"categories":["2021/8"],"content":"传送门 ","date":"2021-08-28","objectID":"/posts/cf1562e/:0:0","tags":["codeforces","suffix array","sparse table"],"title":"Codeforces 1562E Rescue Niwen!","uri":"/posts/cf1562e/"},{"categories":["2021/8"],"content":"题意 将一个字符串按如下形式拆分为若干个串： 以$abcd$为例，拆分为$a,ab,abc,abcd,b,bc,bcd,c,cd,d$ 输出最长的字典序严格上升的子序列（可以不连续）的长度 ","date":"2021-08-28","objectID":"/posts/cf1562e/:0:1","tags":["codeforces","suffix array","sparse table"],"title":"Codeforces 1562E Rescue Niwen!","uri":"/posts/cf1562e/"},{"categories":["2021/8"],"content":"思路 将所有串按原串后缀分组 对于任意后缀$i$，其最大贡献为$n-i+1$，当且仅当后缀$j\u003ei$且$rk[j]\u003erk[i]$时，后缀$j$可置于后缀$i$之后，且贡献度为$n-i+1-lcp(i,j)$ ","date":"2021-08-28","objectID":"/posts/cf1562e/:0:2","tags":["codeforces","suffix array","sparse table"],"title":"Codeforces 1562E Rescue Niwen!","uri":"/posts/cf1562e/"},{"categories":["2021/8"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int maxn=5e3+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; ll ans[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=75; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]-'0'+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } int st[maxn][30],plg[maxn]; void ST_pre(){ plg[1]=0; for(int i=2;i\u003c=n;i++)plg[i]=plg[i/2]+1; for(int i=1;i\u003c=n;i++)st[i][0]=ht[i]; for(int j=1;j\u003c=plg[n];j++){ for(int i=1;i\u003c=n-(1\u003c\u003cj)+1;i++){ st[i][j]=min(st[i][j-1],st[i+(1\u003c\u003c(j-1))][j-1]); } } } int ST_query(int l,int r){ int k=plg[r-l+1]; return min(st[l][k],st[r-(1\u003c\u003ck)+1][k]); } int lcp(int a,int b){//排名第a的后缀与排名第b的后缀的最长公共前缀 if(a\u003eb)swap(a,b); return ST_query(a+1,b); } inline void solve(){ cin\u003e\u003en\u003e\u003e(s+1); SuffixArray(); Height(); ST_pre(); ll res=0; for(int i=1;i\u003c=n;i++){ int x=sa[i]; ans[x]=n-x+1; for(int j=1;j\u003ci;j++){ if(sa[j]\u003cx)ans[x]=max(ans[x],ans[sa[j]]+n-x+1-lcp(j,i)); } res=max(res,ans[x]); } cout\u003c\u003cres\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-08-28","objectID":"/posts/cf1562e/:0:3","tags":["codeforces","suffix array","sparse table"],"title":"Codeforces 1562E Rescue Niwen!","uri":"/posts/cf1562e/"},{"categories":["2021/8"],"content":"小结 最近一直在学的后缀数组居然现场遇到了没做出来，真是离紫名最近的一回 😭 ","date":"2021-08-28","objectID":"/posts/cf1562e/:0:4","tags":["codeforces","suffix array","sparse table"],"title":"Codeforces 1562E Rescue Niwen!","uri":"/posts/cf1562e/"},{"categories":["2021/8"],"content":"传送门 ","date":"2021-08-25","objectID":"/posts/poj3463/:0:0","tags":["poj","dijkstra"],"title":"POJ 3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"题意 给一张图，求到终点最短路个数以及与最短路相差为1的次短路的个数之和 ","date":"2021-08-25","objectID":"/posts/poj3463/:0:1","tags":["poj","dijkstra"],"title":"POJ 3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"思路 最短路计数和次短路计数的模板题，将次短路丢入优先队列中即可。 ","date":"2021-08-25","objectID":"/posts/poj3463/:0:2","tags":["poj","dijkstra"],"title":"POJ 3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"代码 /** * Author: ShacozzZ * Created: 2021-08-25 21:23:21 **/ #include\u003calgorithm\u003e#include\u003ciostream\u003e#include\u003cmap\u003e#include\u003cqueue\u003e#include\u003cvector\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef long long ll; typedef pair\u003cint,int\u003e P; const int inf=0x3f3f3f3f; const int maxn=1e5+5; int n,m; struct edge{ int v,w; edge(){} edge(int vv,int ww){v=vv;w=ww;} }; struct node{ int x,y,z; node(){} node(int xx,int yy,int zz){x=xx;y=yy;z=zz;} bool operator\u003e(const node \u0026b)const{return x\u003eb.x;} }; vector\u003cedge\u003e g[maxn]; int st,en,dis1[maxn],dis2[maxn],cnt1[maxn],cnt2[maxn]; void init(){ for(int i=0;i\u003c=n;i++){ g[i].clear(); dis1[i]=dis2[i]=inf; cnt1[i]=cnt2[i]=0; } } void dij(){ priority_queue\u003cnode,vector\u003cnode\u003e,greater\u003cnode\u003e\u003e q; dis1[st]=0; cnt1[st]=1; q.push(node(0,st,1)); while(!q.empty()){ node p=q.top(); q.pop(); int u=p.y; int d=p.x; int num=(p.z==1?cnt1[u]:cnt2[u]); if(p.z==1\u0026\u0026dis1[u]\u003cp.x)continue; if(p.z==2\u0026\u0026dis2[u]\u003cp.x)continue; for(int i=0;i\u003cg[u].size();i++){ int v=g[u][i].v,w=g[u][i].w; if(d+w\u003cdis1[v]){ dis2[v]=dis1[v]; cnt2[v]=cnt1[v]; q.push(node(dis2[v],v,2)); dis1[v]=d+w; cnt1[v]=num; q.push(node(dis1[v],v,1)); }else if(d+w==dis1[v])cnt1[v]+=num; else if(d+w\u003cdis2[v]){ dis2[v]=d+w; cnt2[v]=num; q.push(node(dis2[v],v,2)); }else if(d+w==dis2[v])cnt2[v]+=num; } } } inline void solve(){ cin\u003e\u003en\u003e\u003em; int u,v,w; init(); for(int i=0;i\u003cm;i++){ cin\u003e\u003eu\u003e\u003ev\u003e\u003ew; g[u].push_back(edge(v,w)); } cin\u003e\u003est\u003e\u003een; dij(); cout\u003c\u003c(dis2[en]-dis1[en]==1?cnt1[en]+cnt2[en]:cnt1[en])\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-08-25","objectID":"/posts/poj3463/:0:3","tags":["poj","dijkstra"],"title":"POJ 3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"小结 对最短路的理解又加深了（好耶 ","date":"2021-08-25","objectID":"/posts/poj3463/:0:4","tags":["poj","dijkstra"],"title":"POJ 3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"传送门 ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:0","tags":["gym","dp","tree"],"title":"2021CCPC东北四省赛 C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"题意 问有多少种删点方案使得剩下的点至少与一个点相连 ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:1","tags":["gym","dp","tree"],"title":"2021CCPC东北四省赛 C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"思路 定义$dp[i][0/1/2]$代表对于节点i为根的子树，将节点$i$删去、保留节点$i$且节点$i$只与父节点相连、保留节点$i$且与子节点相连的方案数 对于第三种情况，通过先算得保留节点i的所有方案数减去不合法的方案数，即减去第二种情况的方案数 状态转移方程如下： $dp[u][0]=\\prod_{v\\in son_{u}}(dp[v][0]+dp[v][2])$ $dp[u][1]=\\prod_{v\\in son_{u}}dp[v][0]$ $dp[u][2]=\\prod_{v\\in son_{u}}(dp[v][0]+dp[v][1]+dp[v][2])-dp[u][1]$ ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:2","tags":["gym","dp","tree"],"title":"2021CCPC东北四省赛 C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int md=998244353; const int maxn=2e5+5; int n,m; ll dp[maxn][3]; vector\u003cint\u003e g[maxn]; void dfs(int u,int fa){ for(int v:g[u]){ if(v==fa)continue; dfs(v,u); dp[u][0]=dp[u][0]*(dp[v][0]+dp[v][2])%md;; dp[u][1]=dp[u][1]*dp[v][0]%md; dp[u][2]=dp[u][2]*(dp[v][0]+dp[v][1]+dp[v][2])%md; } dp[u][2]-=dp[u][1]; if(dp[u][2])dp[u][2]+=md; } inline void solve(){ cin\u003e\u003en; for(int i=1;i\u003c=n;i++)dp[i][0]=dp[i][1]=dp[i][2]=1,g[i].clear(); int u,v; for(int i=1;i\u003cn;i++){ cin\u003e\u003eu\u003e\u003ev; g[u].push_back(v); g[v].push_back(u); } dfs(1,0); cout\u003c\u003c(dp[1][0]+dp[1][2])%md\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:3","tags":["gym","dp","tree"],"title":"2021CCPC东北四省赛 C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"小结 训练赛补题，离谱的事在训练赛时手动模拟都没有数出样例中的22种方案（笑） ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:4","tags":["gym","dp","tree"],"title":"2021CCPC东北四省赛 C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/7"],"content":"传送门 ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:0","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces 1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"题意 给一个数组，分割成三个区间，使得左区间的最大值等于中间区间的最小值等于右区间的最大值 ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:1","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces 1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"思路 首先用线段树维护区间的最大值最小值不难想到，然后遍历数组，再确定一个断点的条件（即确定了左区间）下，发现另外一个断点所确定的两个区间的最大值和最小值都是具有单调性的，即：中间区间越大则最小值越小且右区间最大值越小 时间复杂度$O(nlognlogn)$ ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:2","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces 1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int inf=0x3f3f3f3f; const int maxn=2e5+5; int n,m,a[maxn]; ll num[maxn]; struct seq_node{ int l,r; ll mn,mx; }tree[maxn\u003c\u003c2]; inline void pushup(int o){ tree[o].mn=min(tree[o\u003c\u003c1].mn,tree[o\u003c\u003c1|1].mn); tree[o].mx=max(tree[o\u003c\u003c1].mx,tree[o\u003c\u003c1|1].mx); } void build_tree(int l,int r,int o){ tree[o].l=l,tree[o].r=r; if(l==r){ tree[o].mx=tree[o].mn=num[l]; return ; } int mid=(l+r)\u003e\u003e1; build_tree(l,mid,o\u003c\u003c1); build_tree(mid+1,r,o\u003c\u003c1|1); pushup(o); } int query_mx(int l,int r,int o){ if(tree[o].l\u003e=l\u0026\u0026tree[o].r\u003c=r)return tree[o].mx; int mid=(tree[o].l+tree[o].r)\u003e\u003e1; int mx=0; if(l\u003c=mid)mx=max(mx,query_mx(l,r,o\u003c\u003c1)); if(r\u003emid)mx=max(mx,query_mx(l,r,o\u003c\u003c1|1)); return mx; } int query_mn(int l,int r,int o){ if(tree[o].l\u003e=l\u0026\u0026tree[o].r\u003c=r)return tree[o].mn; int mid=(tree[o].l+tree[o].r)\u003e\u003e1; int mn=inf; if(l\u003c=mid)mn=min(mn,query_mn(l,r,o\u003c\u003c1)); if(r\u003emid)mn=min(mn,query_mn(l,r,o\u003c\u003c1|1)); return mn; } inline void solve(){ cin\u003e\u003en; for(int i=1;i\u003c=n;i++)cin\u003e\u003enum[i]; build_tree(1,n,1); for(int i=1;i\u003cn-1;i++){ int l=i+1,r=n-1; int mx1=query_mx(1,i,1),mn,mx2; while(l\u003c=r){ int mid=(l+r)\u003e\u003e1; // ck(mid) mn=query_mn(i+1,mid,1); mx2=query_mx(mid+1,n,1); if(mn\u003emx1||mx2\u003emx1)l=mid+1; else if(mn\u003cmx1||mx2\u003cmx1)r=mid-1; else{ cout\u003c\u003c\"YES\"\u003c\u003cendl; cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cmid-i\u003c\u003c\" \"\u003c\u003cn-mid\u003c\u003cendl; return ; } } } cout\u003c\u003c\"NO\"\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:3","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces 1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"小结 大概是稍微复习了一下线段树，二分的思路很巧妙，也是通过看了别人的题解才想到的 ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:4","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces 1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"传送门 ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:0","tags":["codeforces","dfs"],"title":"Codeforces 1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"题意 给$n$个点$n$条边的无向图，求有多少条简单路径 ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:1","tags":["codeforces","dfs"],"title":"Codeforces 1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"思路 不难发现图为一棵树增加一条边使得树中出现了一个环，首先找出环，然后如果两个点之间经过环，则有两条简单路径，否则为一条 通过两次dfs，第一次找出有哪些点在环上，第二次计算答案 ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:2","tags":["codeforces","dfs"],"title":"Codeforces 1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int maxn=2e5+5; const int maxm=1e9; ll n,m,ans; vector\u003cint\u003e g[maxn]; set\u003cint\u003e c; bool vis[maxn]; int fa[maxn]; bool ok=0; void init(){} void dfs1(int u){ vis[u]=1; for(int i=0;i\u003cg[u].size();i++){ if(ok)return ; int v=g[u][i]; if(v!=fa[u]){ if(vis[v]){ while(u!=v){ c.insert(u); u=fa[u]; } c.insert(v); ok=1; }else{ fa[v]=u; dfs1(v); } } } } ll dfs2(int u){ ll res=1; vis[u]=1; for(int i=0;i\u003cg[u].size();i++){ int v=g[u][i]; if(!vis[v]\u0026\u0026(!c.count(u)||!c.count(v))){ res+=dfs2(v); } } return res; } inline void solve(){ cin\u003e\u003en; for(int i=0;i\u003c=n;i++){ g[i].clear(); vis[i]=0; } c.clear(); ans=ok=0; for(int i=1;i\u003c=n;i++){ int u,v; cin\u003e\u003eu\u003e\u003ev; g[u].push_back(v); g[v].push_back(u); } dfs1(1); for(int i=0;i\u003c=n;i++)vis[i]=0; for(int i=1;i\u003c=n;i++){ if(!vis[i]){ ll res=dfs2(i); ans+=res*(res-1)/2+res*(n-res); } } cout\u003c\u003cans\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:3","tags":["codeforces","dfs"],"title":"Codeforces 1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"小结 很简单的一个题，零零碎碎的bug找了太久了 ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:4","tags":["codeforces","dfs"],"title":"Codeforces 1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"传送门 ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:0","tags":["codeforces","topological sorting"],"title":"Codeforces 1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"题意 给一个图包含有向边和无向边，将所有无向边改为有向边并且使图中不存在环 ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:1","tags":["codeforces","topological sorting"],"title":"Codeforces 1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"思路 首先删除掉所有有向边，通过拓扑排序判断是否有环，如果不存在环，则将无向边改为由拓扑序小的点指向拓扑序大的点的有向边 ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:2","tags":["codeforces","topological sorting"],"title":"Codeforces 1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef pair\u003cint,int\u003e Pii; const int maxn=2e5+5; int n,m,rk[maxn]; vector\u003cPii\u003e e; void init(){} vector\u003cint\u003e g[maxn]; vector\u003cint\u003e topo; int vis[maxn]; bool dfs(int u){ vis[u]=-1; for(auto v:g[u]){ if(vis[v]\u003c0)return 0; else if(!vis[v]\u0026\u0026!dfs(v))return 0; } vis[u]=1; topo.push_back(u); return 1; } bool toposort(){ topo.clear(); for(int i=0;i\u003c=n;i++)vis[i]=0; for(int u=1;u\u003c=n;u++){ if(!vis[u]\u0026\u0026!dfs(u))return 0; } reverse(topo.begin(),topo.end()); return 1; } inline void solve(){ cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++){ vis[i]=0; g[i].clear(); } e.clear(); for(int i=0;i\u003cm;i++){ int u,v,w; cin\u003e\u003ew\u003e\u003eu\u003e\u003ev; if(w){ g[u].push_back(v); in[v]++; }else e.push_back({u,v}); } if(!toposort()){ cout\u003c\u003c\"NO\"\u003c\u003cendl; return ; } for(int i=0;i\u003ctopo.size();i++)rk[topo[i]]=i; cout\u003c\u003c\"YES\"\u003c\u003cendl; for(int u=1;u\u003c=n;u++){ for(auto v:g[u])cout\u003c\u003cu\u003c\u003c\" \"\u003c\u003cv\u003c\u003cendl; } for(auto p:e){ if(rk[p.x]\u003crk[p.y])cout\u003c\u003cp.x\u003c\u003c\" \"\u003c\u003cp.y\u003c\u003cendl; else cout\u003c\u003cp.y\u003c\u003c\" \"\u003c\u003cp.x\u003c\u003cendl; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef pair\u003cint,int\u003e Pii; const int maxn=2e5+5; int n,m,rk[maxn]; vector\u003cPii\u003e e; void init(){} vector\u003cint\u003e g[maxn]; vector\u003cint\u003e topo; int in[maxn]; bool toposort(){ topo.clear(); for(int u=1;u\u003c=n;u++){ for(auto v:g[u])in[v]++; } int cnt=0; queue\u003cint\u003e q; for(int u=1;u\u003c=n;u++)if(!in[u])q.push(u); while(q.size()){ int u=q.front(); q.pop(); cnt++; topo.push_back(u); for(auto v:g[u])if(!--in[v])q.push(v); } return cnt==n; } inline void solve(){ cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++){ in[i]=0; g[i].clear(); } e.clear(); for(int i=0;i\u003cm;i++){ int u,v,w; cin\u003e\u003ew\u003e\u003eu\u003e\u003ev; if(w){ g[u].push_back(v); }else e.push_back({u,v}); } if(!toposort()){ cout\u003c\u003c\"NO\"\u003c\u003cendl; return ; } for(int i=0;i\u003ctopo.size();i++)rk[topo[i]]=i; cout\u003c\u003c\"YES\"\u003c\u003cendl; for(int u=1;u\u003c=n;u++){ for(auto v:g[u])cout\u003c\u003cu\u003c\u003c\" \"\u003c\u003cv\u003c\u003cendl; } for(auto p:e){ if(rk[p.x]\u003crk[p.y])cout\u003c\u003cp.x\u003c\u003c\" \"\u003c\u003cp.y\u003c\u003cendl; else cout\u003c\u003cp.y\u003c\u003c\" \"\u003c\u003cp.x\u003c\u003cendl; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:3","tags":["codeforces","topological sorting"],"title":"Codeforces 1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"小结 很久没有刷过图论，通过这个题算是复习了一下拓扑排序 ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:4","tags":["codeforces","topological sorting"],"title":"Codeforces 1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"传送门 ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:0","tags":["codeforces","string hash"],"title":"Codeforces 1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"题意 给n个字符串合并成一个串并且合并时消除后一个串最长的与前一个串后缀相同的前缀，即ab与bc合并为abc ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:1","tags":["codeforces","string hash"],"title":"Codeforces 1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"思路 将字符串hash之后暴力寻找最长的相同前后缀即可。由于codeforces的数据还是比较强的，为了防止hash碰撞，有两种解决方法 双模数hash 在找到相同的hash值之后暴力判断该前缀和该后缀是否真正相同 ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:2","tags":["codeforces","string hash"],"title":"Codeforces 1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef unsigned long long ull; typedef pair\u003cull,ull\u003e P; const int md1=998244353; const int md2=1e9+7; const ull B1=233,B2=131; const int maxn=1e6+5; int n,m; string t,s; vector\u003cP\u003e pre,ss,tt; void init(){ pre.push_back(P(1,1)); for(int i=1;i\u003cmaxn;i++)pre.push_back(P(pre[i-1].x*B1%md1,pre[i-1].y*B2%md2)); } inline void solve(){ cin\u003e\u003en; t.push_back('*'); tt.push_back(P(0,0)); while(cin\u003e\u003es){ ss.clear(); ss.push_back(P(0,0)); for(int i=1;i\u003c=s.size();i++)ss.push_back(P((ss[i-1].x*B1+s[i-1])%md1,(ss[i-1].y*B2+s[i-1])%md2)); int len=0; for(int i=min(t.size(),s.size());i\u003e0;i--){ if((tt[t.size()-1].x+md1-tt[t.size()-i-1].x*pre[i].x%md1)%md1==ss[i].x \u0026\u0026(tt[t.size()-1].y+md2-tt[t.size()-i-1].y*pre[i].y%md2)%md2==ss[i].y){ len=i; break; } } for(int i=len,j=t.size();i\u003cs.size();i++,j++){ t.push_back(s[i]); tt.push_back(P((tt[j-1].x*B1+s[i])%md1,(tt[j-1].y*B2+s[i])%md2)); } } for(int i=1;i\u003ct.size();i++)cout\u003c\u003ct[i]; cout\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; init(); while(__--){ solve(); } return 0; } #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef unsigned long long ull; const ull B=233; int n,m; string t,s; vector\u003cull\u003e pre,ss,tt; void init(){ pre.push_back(1); for(int i=1;i\u003cmaxn;i++)pre.push_back(pre[i-1]*B); } inline void solve(){ cin\u003e\u003en; t.push_back('*'); tt.push_back(0); while(cin\u003e\u003es){ ss.clear(); ss.push_back(0); for(int i=1;i\u003c=s.size();i++)ss.push_back(ss[i-1]*B+s[i-1]); int len=0; for(int i=min(t.size(),s.size());i\u003e0;i--){ if(tt[t.size()-1]-tt[t.size()-i-1]*pre[i]==ss[i]){ bool ok=1; for(int j=t.size()-i,k=0;j\u003ct.size()\u0026\u0026k\u003ci;j++,k++){ if(t[j]!=s[k]){ ok=0; break; } } if(ok){ len=i; break; } } } for(int i=len,j=t.size();i\u003cs.size();i++,j++){ t.push_back(s[i]); tt.push_back(tt[j-1]*B+s[i]); } } for(int i=1;i\u003ct.size();i++)cout\u003c\u003ct[i]; cout\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; init(); while(__--){ solve(); } return 0; } ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:3","tags":["codeforces","string hash"],"title":"Codeforces 1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"小结 不得不吐槽Codeforces的数据太狠了（可想当时比赛的时候被hack了多少人），主要注意的是unsigned long long 自然溢出这种hash方式貌似很容易被卡 ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:4","tags":["codeforces","string hash"],"title":"Codeforces 1200E Compress Words","uri":"/posts/cf1200e/"}]