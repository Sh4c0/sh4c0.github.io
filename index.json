[{"categories":["2021/8"],"content":"传送门 ","date":"2021-08-25","objectID":"/posts/poj3463/:0:0","tags":["poj","dijkstra"],"title":"POJ3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"题意 给一张图，求最短路个数以及与最短路相差为1的次短路的个数之和 ","date":"2021-08-25","objectID":"/posts/poj3463/:0:1","tags":["poj","dijkstra"],"title":"POJ3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"思路 最短路计数和次短路计数的模板题，将次短路丢入优先队列中即可。 ","date":"2021-08-25","objectID":"/posts/poj3463/:0:2","tags":["poj","dijkstra"],"title":"POJ3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"代码 /** * Author: ShacozzZ * Created: 2021-08-25 21:23:21 **/ #include\u003calgorithm\u003e#include\u003ciostream\u003e#include\u003cmap\u003e#include\u003cqueue\u003e#include\u003cvector\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef long long ll; typedef pair\u003cint,int\u003e P; const int inf=0x3f3f3f3f; const int maxn=1e5+5; int n,m; struct edge{ int v,w; edge(){} edge(int vv,int ww){v=vv;w=ww;} }; struct node{ int x,y,z; node(){} node(int xx,int yy,int zz){x=xx;y=yy;z=zz;} bool operator\u003e(const node \u0026b)const{return x\u003eb.x;} }; vector\u003cedge\u003e g[maxn]; int st,en,dis1[maxn],dis2[maxn],cnt1[maxn],cnt2[maxn]; void init(){ for(int i=0;i\u003c=n;i++){ g[i].clear(); dis1[i]=dis2[i]=inf; cnt1[i]=cnt2[i]=0; } } void dij(){ priority_queue\u003cnode,vector\u003cnode\u003e,greater\u003cnode\u003e\u003e q; dis1[st]=0; cnt1[st]=1; q.push(node(0,st,1)); while(!q.empty()){ node p=q.top(); q.pop(); int u=p.y; int d=p.x; int num=(p.z==1?cnt1[u]:cnt2[u]); if(p.z==1\u0026\u0026dis1[u]\u003cp.x)continue; if(p.z==2\u0026\u0026dis2[u]\u003cp.x)continue; for(int i=0;i\u003cg[u].size();i++){ int v=g[u][i].v,w=g[u][i].w; if(d+w\u003cdis1[v]){ dis2[v]=dis1[v]; cnt2[v]=cnt1[v]; q.push(node(dis2[v],v,2)); dis1[v]=d+w; cnt1[v]=num; q.push(node(dis1[v],v,1)); }else if(d+w==dis1[v])cnt1[v]+=num; else if(d+w\u003cdis2[v]){ dis2[v]=d+w; cnt2[v]=num; q.push(node(dis2[v],v,2)); }else if(d+w==dis2[v])cnt2[v]+=num; } } } inline void solve(){ cin\u003e\u003en\u003e\u003em; int u,v,w; init(); for(int i=0;i\u003cm;i++){ cin\u003e\u003eu\u003e\u003ev\u003e\u003ew; g[u].push_back(edge(v,w)); } cin\u003e\u003est\u003e\u003een; dij(); cout\u003c\u003c(dis2[en]-dis1[en]==1?cnt1[en]+cnt2[en]:cnt1[en])\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-08-25","objectID":"/posts/poj3463/:0:3","tags":["poj","dijkstra"],"title":"POJ3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"小结 对最短路的理解又加深了（好耶 ","date":"2021-08-25","objectID":"/posts/poj3463/:0:4","tags":["poj","dijkstra"],"title":"POJ3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"传送门 ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:0","tags":["gym","dp","tree"],"title":"2021CCPC东北四省赛C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"题意 问有多少种删点方案使得剩下的点至少与一个点相连 ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:1","tags":["gym","dp","tree"],"title":"2021CCPC东北四省赛C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"思路 定义dp[i][0/1/2]代表对于节点i为根的子树，将节点i删去、保留节点i且节点i只与父节点相连、保留节点i且与子节点相连的方案数 对于第三种情况，通过先算得保留节点i的所有方案数减去不合法的方案数，即减去第二种情况的方案数 状态转移方程如下： $dp[u][0]=\\prod_{v\\in son_{u}}(dp[v][0]+dp[v][2])$ $dp[u][1]=\\prod_{v\\in son_{u}}dp[v][0]$ $dp[u][2]=\\prod_{v\\in son_{u}}(dp[v][0]+dp[v][1]+dp[v][2])-dp[u][1]$ ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:2","tags":["gym","dp","tree"],"title":"2021CCPC东北四省赛C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int md=998244353; const int maxn=2e5+5; int n,m; ll dp[maxn][3]; vector\u003cint\u003e g[maxn]; void dfs(int u,int fa){ for(int v:g[u]){ if(v==fa)continue; dfs(v,u); dp[u][0]=dp[u][0]*(dp[v][0]+dp[v][2])%md;; dp[u][1]=dp[u][1]*dp[v][0]%md; dp[u][2]=dp[u][2]*(dp[v][0]+dp[v][1]+dp[v][2])%md; } dp[u][2]-=dp[u][1]; if(dp[u][2])dp[u][2]+=md; } inline void solve(){ cin\u003e\u003en; for(int i=1;i\u003c=n;i++)dp[i][0]=dp[i][1]=dp[i][2]=1,g[i].clear(); int u,v; for(int i=1;i\u003cn;i++){ cin\u003e\u003eu\u003e\u003ev; g[u].push_back(v); g[v].push_back(u); } dfs(1,0); cout\u003c\u003c(dp[1][0]+dp[1][2])%md\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:3","tags":["gym","dp","tree"],"title":"2021CCPC东北四省赛C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"小结 训练赛补题，离谱的事在训练赛时手动模拟都没有数出样例中的22种方案（笑） ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:4","tags":["gym","dp","tree"],"title":"2021CCPC东北四省赛C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/7"],"content":"传送门 ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:0","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"题意 给一个数组，分割成三个区间，使得左区间的最大值等于中间区间的最小值等于右区间的最大值 ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:1","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"思路 首先用线段树维护区间的最大值最小值不难想到，然后遍历数组，再确定一个断点的条件（即确定了左区间）下，发现另外一个断点所确定的两个区间的最大值和最小值都是具有单调性的，即：中间区间越大则最小值越小且右区间最大值越小 时间复杂度O(nlognlogn) ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:2","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int inf=0x3f3f3f3f; const int maxn=2e5+5; int n,m,a[maxn]; ll num[maxn]; struct seq_node{ int l,r; ll mn,mx; }tree[maxn\u003c\u003c2]; inline void pushup(int o){ tree[o].mn=min(tree[o\u003c\u003c1].mn,tree[o\u003c\u003c1|1].mn); tree[o].mx=max(tree[o\u003c\u003c1].mx,tree[o\u003c\u003c1|1].mx); } void build_tree(int l,int r,int o){ tree[o].l=l,tree[o].r=r; if(l==r){ tree[o].mx=tree[o].mn=num[l]; return ; } int mid=(l+r)\u003e\u003e1; build_tree(l,mid,o\u003c\u003c1); build_tree(mid+1,r,o\u003c\u003c1|1); pushup(o); } int query_mx(int l,int r,int o){ if(tree[o].l\u003e=l\u0026\u0026tree[o].r\u003c=r)return tree[o].mx; int mid=(tree[o].l+tree[o].r)\u003e\u003e1; int mx=0; if(l\u003c=mid)mx=max(mx,query_mx(l,r,o\u003c\u003c1)); if(r\u003emid)mx=max(mx,query_mx(l,r,o\u003c\u003c1|1)); return mx; } int query_mn(int l,int r,int o){ if(tree[o].l\u003e=l\u0026\u0026tree[o].r\u003c=r)return tree[o].mn; int mid=(tree[o].l+tree[o].r)\u003e\u003e1; int mn=inf; if(l\u003c=mid)mn=min(mn,query_mn(l,r,o\u003c\u003c1)); if(r\u003emid)mn=min(mn,query_mn(l,r,o\u003c\u003c1|1)); return mn; } inline void solve(){ cin\u003e\u003en; for(int i=1;i\u003c=n;i++)cin\u003e\u003enum[i]; build_tree(1,n,1); for(int i=1;i\u003cn-1;i++){ int l=i+1,r=n-1; int mx1=query_mx(1,i,1),mn,mx2; while(l\u003c=r){ int mid=(l+r)\u003e\u003e1; // ck(mid) mn=query_mn(i+1,mid,1); mx2=query_mx(mid+1,n,1); if(mn\u003emx1||mx2\u003emx1)l=mid+1; else if(mn\u003cmx1||mx2\u003cmx1)r=mid-1; else{ cout\u003c\u003c\"YES\"\u003c\u003cendl; cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cmid-i\u003c\u003c\" \"\u003c\u003cn-mid\u003c\u003cendl; return ; } } } cout\u003c\u003c\"NO\"\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:3","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"小结 大概是稍微复习了一下线段树，二分的思路很巧妙，也是通过看了别人的题解才想到的 ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:4","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"传送门 ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:0","tags":["codeforces","dfs"],"title":"Codeforces1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"题意 给n个点n条边的无向图，求有多少条简单路径 ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:1","tags":["codeforces","dfs"],"title":"Codeforces1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"思路 不难发现图为一棵树增加一条边使得树中出现了一个环，首先找出环，然后如果两个点之间经过环，则有两条简单路径，否则为一条 通过两次dfs，第一次找出有哪些点在环上，第二次计算答案 ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:2","tags":["codeforces","dfs"],"title":"Codeforces1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int maxn=2e5+5; const int maxm=1e9; ll n,m,ans; vector\u003cint\u003e g[maxn]; set\u003cint\u003e c; bool vis[maxn]; int fa[maxn]; bool ok=0; void init(){} void dfs1(int u){ vis[u]=1; for(int i=0;i\u003cg[u].size();i++){ if(ok)return ; int v=g[u][i]; if(v!=fa[u]){ if(vis[v]){ while(u!=v){ c.insert(u); u=fa[u]; } c.insert(v); ok=1; }else{ fa[v]=u; dfs1(v); } } } } ll dfs2(int u){ ll res=1; vis[u]=1; for(int i=0;i\u003cg[u].size();i++){ int v=g[u][i]; if(!vis[v]\u0026\u0026(!c.count(u)||!c.count(v))){ res+=dfs2(v); } } return res; } inline void solve(){ cin\u003e\u003en; for(int i=0;i\u003c=n;i++){ g[i].clear(); vis[i]=0; } c.clear(); ans=ok=0; for(int i=1;i\u003c=n;i++){ int u,v; cin\u003e\u003eu\u003e\u003ev; g[u].push_back(v); g[v].push_back(u); } dfs1(1); for(int i=0;i\u003c=n;i++)vis[i]=0; for(int i=1;i\u003c=n;i++){ if(!vis[i]){ ll res=dfs2(i); ans+=res*(res-1)/2+res*(n-res); } } cout\u003c\u003cans\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:3","tags":["codeforces","dfs"],"title":"Codeforces1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"小结 很简单的一个题，零零碎碎的bug找了太久了 ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:4","tags":["codeforces","dfs"],"title":"Codeforces1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"传送门 ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:0","tags":["codeforces","topological sorting"],"title":"Codeforces1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"题意 给一个图包含有向边和无向边，将所有无向边改为有向边并且使图中不存在环 ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:1","tags":["codeforces","topological sorting"],"title":"Codeforces1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"思路 首先删除掉所有有向边，通过拓扑排序判断是否有环，如果不存在环，则将无向边改为由拓扑序小的点指向拓扑序大的点的有向边 ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:2","tags":["codeforces","topological sorting"],"title":"Codeforces1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef pair\u003cint,int\u003e Pii; const int maxn=2e5+5; int n,m,rk[maxn]; vector\u003cPii\u003e e; void init(){} vector\u003cint\u003e g[maxn]; vector\u003cint\u003e topo; int vis[maxn]; bool dfs(int u){ vis[u]=-1; for(auto v:g[u]){ if(vis[v]\u003c0)return 0; else if(!vis[v]\u0026\u0026!dfs(v))return 0; } vis[u]=1; topo.push_back(u); return 1; } bool toposort(){ topo.clear(); for(int i=0;i\u003c=n;i++)vis[i]=0; for(int u=1;u\u003c=n;u++){ if(!vis[u]\u0026\u0026!dfs(u))return 0; } reverse(topo.begin(),topo.end()); return 1; } inline void solve(){ cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++){ vis[i]=0; g[i].clear(); } e.clear(); for(int i=0;i\u003cm;i++){ int u,v,w; cin\u003e\u003ew\u003e\u003eu\u003e\u003ev; if(w){ g[u].push_back(v); in[v]++; }else e.push_back({u,v}); } if(!toposort()){ cout\u003c\u003c\"NO\"\u003c\u003cendl; return ; } for(int i=0;i\u003ctopo.size();i++)rk[topo[i]]=i; cout\u003c\u003c\"YES\"\u003c\u003cendl; for(int u=1;u\u003c=n;u++){ for(auto v:g[u])cout\u003c\u003cu\u003c\u003c\" \"\u003c\u003cv\u003c\u003cendl; } for(auto p:e){ if(rk[p.x]\u003crk[p.y])cout\u003c\u003cp.x\u003c\u003c\" \"\u003c\u003cp.y\u003c\u003cendl; else cout\u003c\u003cp.y\u003c\u003c\" \"\u003c\u003cp.x\u003c\u003cendl; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef pair\u003cint,int\u003e Pii; const int maxn=2e5+5; int n,m,rk[maxn]; vector\u003cPii\u003e e; void init(){} vector\u003cint\u003e g[maxn]; vector\u003cint\u003e topo; int in[maxn]; bool toposort(){ topo.clear(); for(int u=1;u\u003c=n;u++){ for(auto v:g[u])in[v]++; } int cnt=0; queue\u003cint\u003e q; for(int u=1;u\u003c=n;u++)if(!in[u])q.push(u); while(q.size()){ int u=q.front(); q.pop(); cnt++; topo.push_back(u); for(auto v:g[u])if(!--in[v])q.push(v); } return cnt==n; } inline void solve(){ cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++){ in[i]=0; g[i].clear(); } e.clear(); for(int i=0;i\u003cm;i++){ int u,v,w; cin\u003e\u003ew\u003e\u003eu\u003e\u003ev; if(w){ g[u].push_back(v); }else e.push_back({u,v}); } if(!toposort()){ cout\u003c\u003c\"NO\"\u003c\u003cendl; return ; } for(int i=0;i\u003ctopo.size();i++)rk[topo[i]]=i; cout\u003c\u003c\"YES\"\u003c\u003cendl; for(int u=1;u\u003c=n;u++){ for(auto v:g[u])cout\u003c\u003cu\u003c\u003c\" \"\u003c\u003cv\u003c\u003cendl; } for(auto p:e){ if(rk[p.x]\u003crk[p.y])cout\u003c\u003cp.x\u003c\u003c\" \"\u003c\u003cp.y\u003c\u003cendl; else cout\u003c\u003cp.y\u003c\u003c\" \"\u003c\u003cp.x\u003c\u003cendl; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:3","tags":["codeforces","topological sorting"],"title":"Codeforces1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"小结 很久没有刷过图论，通过这个题算是复习了一下拓扑排序 ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:4","tags":["codeforces","topological sorting"],"title":"Codeforces1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"传送门 ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:0","tags":["codeforces","string hash"],"title":"Codeforces1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"题意 给n个字符串合并成一个串并且合并时消除后一个串最长的与前一个串后缀相同的前缀，即ab与bc合并为abc ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:1","tags":["codeforces","string hash"],"title":"Codeforces1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"思路 将字符串hash之后暴力寻找最长的相同前后缀即可。由于codeforces的数据还是比较强的，为了防止hash碰撞，有两种解决方法 双模数hash 在找到相同的hash值之后暴力判断该前缀和该后缀是否真正相同 ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:2","tags":["codeforces","string hash"],"title":"Codeforces1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef unsigned long long ull; typedef pair\u003cull,ull\u003e P; const int md1=998244353; const int md2=1e9+7; const ull B1=233,B2=131; const int maxn=1e6+5; int n,m; string t,s; vector\u003cP\u003e pre,ss,tt; void init(){ pre.push_back(P(1,1)); for(int i=1;i\u003cmaxn;i++)pre.push_back(P(pre[i-1].x*B1%md1,pre[i-1].y*B2%md2)); } inline void solve(){ cin\u003e\u003en; t.push_back('*'); tt.push_back(P(0,0)); while(cin\u003e\u003es){ ss.clear(); ss.push_back(P(0,0)); for(int i=1;i\u003c=s.size();i++)ss.push_back(P((ss[i-1].x*B1+s[i-1])%md1,(ss[i-1].y*B2+s[i-1])%md2)); int len=0; for(int i=min(t.size(),s.size());i\u003e0;i--){ if((tt[t.size()-1].x+md1-tt[t.size()-i-1].x*pre[i].x%md1)%md1==ss[i].x \u0026\u0026(tt[t.size()-1].y+md2-tt[t.size()-i-1].y*pre[i].y%md2)%md2==ss[i].y){ len=i; break; } } for(int i=len,j=t.size();i\u003cs.size();i++,j++){ t.push_back(s[i]); tt.push_back(P((tt[j-1].x*B1+s[i])%md1,(tt[j-1].y*B2+s[i])%md2)); } } for(int i=1;i\u003ct.size();i++)cout\u003c\u003ct[i]; cout\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; init(); while(__--){ solve(); } return 0; } #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef unsigned long long ull; const ull B=233; int n,m; string t,s; vector\u003cull\u003e pre,ss,tt; void init(){ pre.push_back(1); for(int i=1;i\u003cmaxn;i++)pre.push_back(pre[i-1]*B); } inline void solve(){ cin\u003e\u003en; t.push_back('*'); tt.push_back(0); while(cin\u003e\u003es){ ss.clear(); ss.push_back(0); for(int i=1;i\u003c=s.size();i++)ss.push_back(ss[i-1]*B+s[i-1]); int len=0; for(int i=min(t.size(),s.size());i\u003e0;i--){ if(tt[t.size()-1]-tt[t.size()-i-1]*pre[i]==ss[i]){ bool ok=1; for(int j=t.size()-i,k=0;j\u003ct.size()\u0026\u0026k\u003ci;j++,k++){ if(t[j]!=s[k]){ ok=0; break; } } if(ok){ len=i; break; } } } for(int i=len,j=t.size();i\u003cs.size();i++,j++){ t.push_back(s[i]); tt.push_back(tt[j-1]*B+s[i]); } } for(int i=1;i\u003ct.size();i++)cout\u003c\u003ct[i]; cout\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; init(); while(__--){ solve(); } return 0; } ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:3","tags":["codeforces","string hash"],"title":"Codeforces1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"小结 不得不吐槽Codeforces的数据太狠了（可想当时比赛的时候被hack了多少人），主要注意的是unsigned long long 自然溢出这种hash方式貌似很容易被卡 ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:4","tags":["codeforces","string hash"],"title":"Codeforces1200E Compress Words","uri":"/posts/cf1200e/"}]