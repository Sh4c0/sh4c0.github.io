[{"categories":["2022/4"],"content":"退役记\u0026\u0026icpc昆明站游记 燃えたよ…まっ白に…燃えつきた…まっ白な灰に……| ","date":"2022-04-18","objectID":"/posts/46thicpckunming/:0:0","tags":["Notes"],"title":"退役记\u0026\u0026icpc昆明站游记","uri":"/posts/46thicpckunming/"},{"categories":["2022/4"],"content":"梦开始的地方 既然是回忆录，自然要从梦最开始的地方开始说起啦！ 应该是刚转专业来计算机的国庆，几乎完全不了解ACM也没有加USC@ACM的大群，只是自己一个人在南华oj上刷题，因为在国庆大礼包里排名还不错，然后被塔子哥加了好友算是正式的开始触及这个圈子。 大一的一年里时间还算多，零零碎碎的刷了一大圈水题，南华oj上也保持着题数第一（虽然并没有什么卵用）。校内的比赛也打了一圈——新生赛、校赛，名次也就还行。到大一结束的时候算是顺利的进入了集训队。 ","date":"2022-04-18","objectID":"/posts/46thicpckunming/:0:1","tags":["Notes"],"title":"退役记\u0026\u0026icpc昆明站游记","uri":"/posts/46thicpckunming/"},{"categories":["2022/4"],"content":"积累 暑假集训由于疫情是在线上训的。犹记得那个暑假里过着日夜颠倒的生活，晚上打完CF就点外卖，然后和ywh讨论题解，然后洗澡，再磨蹭到五六点才睡。由于水题刷多了的后遗症，一度不愿意去学算法题，唯一可能做得有一点价值的事情就是CF全勤了。最后阴差阳错的侥幸入选了省赛的队伍名单（如果那个时候没有被入选会不会又是另外的结局呢）。 对于省赛里的印象可能就是被kmp的小结论卡住的D题和在长理和高中死党吃的烤鱼。 大二的一年大概唯二做的两件事就是旷课刷题和旷课打游戏，总而言之就是没有去过几节课。直到现在回忆起大学的几年，除了ACM也想不起自己还干了啥。 icpc沾了疫情线上赛的光打了两场（上海，昆明），结果都铁了。还记得昆明的队名叫做“求求给个铜吧”，现在想想真的羞耻感满满，也不禁有点感慨。当时想着如果能捞到一个铜牌就退役去搞科研或者项目。没想到一年之后的今天我才真正的把ACMer这个头衔摘下。 大二唯二的两个牌除了湖南省赛就是湘潭邀请赛的了，还是铜。一度自闭，恍惚间觉得自己的大二都白训练了从大二初的省赛到大二末的湘潭赛。遗憾的错位相减、遗憾的线段树优化dp，以及第一的队伍“内测度”坐在我们前面，还剩半个小时的时候就已经提前下班掏出扑克开始打牌了（一度成为心魔）。 ","date":"2022-04-18","objectID":"/posts/46thicpckunming/:0:2","tags":["Notes"],"title":"退役记\u0026\u0026icpc昆明站游记","uri":"/posts/46thicpckunming/"},{"categories":["2022/4"],"content":"初战｜沈阳站 然后经历了暑假集训，又是一段时间的刷题之后，开始迎接下一轮的xcpc了。 因为摇随机数摇输了，所以我们队没有ccpc的名额，所以仅有的机会就是两次icpc了。21年的icpc顺序是济南、沈阳、上海、南京，为了避免同校竞争过大，和hz分开报，我们队报了沈阳他们报了济南。济南hz银牌了，直接压力就落在了我们身上。 沈阳真是永远的意难平。 卡在了一道思维题3个小时，致使后面本来能写的题也没有机会写完，抱憾拿铜。 ","date":"2022-04-18","objectID":"/posts/46thicpckunming/:0:3","tags":["Notes"],"title":"退役记\u0026\u0026icpc昆明站游记","uri":"/posts/46thicpckunming/"},{"categories":["2022/4"],"content":"韬光养晦 “没事的嘞，昆明拿银。”沈阳结束后ywh说。 为了有更好地把握拿到牌子，所以一开始的策略就打算把下一站留在第二年的昆明。 可能这是我ACMer生涯中最低谷的一段时间了吧。 同届的找工作的开始找工作了，考研的开始考研了，只有我还在对着黑框调试我的题目。 在寒假里，在开学到现在的时间里。和ywh，wsj两天一场的训练赛，从近几年的xcpc打到14、15年，从国内的打到国外了。CF也保持了全勤。 偶尔在一些场次能一度冲到金牌区，更多的时候是破铜烂铁。 大概是最暗无天日的时间了吧，压力大到整晚睡不着觉。 有时候也总会想如果没有ACM，现在的我应该是怎么样的呢？ ","date":"2022-04-18","objectID":"/posts/46thicpckunming/:0:4","tags":["Notes"],"title":"退役记\u0026\u0026icpc昆明站游记","uri":"/posts/46thicpckunming/"},{"categories":["2022/4"],"content":"前夕 到了四月得知昆明延期了一周，仿佛得到救赎一般（虽然实际上好像并没有什么用，反而更加煎熬）。 把字符串课内容全部都重新学了一遍，然后也还保持着两天一场的训练赛，板子也全部都更新了一遍。 一直到昨天晚上三个人都紧张到自闭还要互相打气。 板子打印了一筐，把感觉能打印的都打印了（不过还是忘记打印葫芦爷的字符串板子了）。 晚上又失眠了，一直到两点都没有睡着。 好在一大早起来感觉精神还不错。 ","date":"2022-04-18","objectID":"/posts/46thicpckunming/:0:5","tags":["Notes"],"title":"退役记\u0026\u0026icpc昆明站游记","uri":"/posts/46thicpckunming/"},{"categories":["2022/4"],"content":"复仇｜昆明站 开场直接就紧张到说话都有点哆嗦。 一直到十分钟都没有队伍ac，有两个队在交K，不过都wa了就没有放在心上。这个时候我差不多读明白了串串题E，wsj在看计算几何L，然后ywh看到菜狗队过了C之后开始读C（没想到居然是金牌题），又过了几分钟没有思路之后发现有队伍过K了，而且人数在逐渐上升，就三个人都开始读K。 读明白之后，我心里大概有了一个思路（其实就是正解），但是没有想明白就没有说了。然后ywh打表找规律，找到了规律，但是复杂度过不去。直到一个小时的时候，我又会想起一开始的思路，拎出来讨论了一下，发现居然暴力对拍拍不出问题，决定冲一发，A了。 然后因为榜比较歪，然后放在我们面前过的比较多的就只有B、G，一个期望题一个概率题。因为在我和wsj的知识盲区内，所以我选择了继续磕一磕串串题E，wsj继续想计算几何L，ywh在BG中选了G开始想。 大概又过了一段时间之后发现过EL的人数仍然很少，我和wsj决定开始想B。有了一个大概的思路之后，发现可能需要dp，于是叫回ywh。ywh听了之后觉得可做，然后正式开始想B，策略变为我继续磕E，然后wsj和ywh想B。 过了很久，我想了一个利用border性质+二分+hash的思路，然后发现思路假了。再刷榜，发现D过的人猛增，而这时我们都还没有人读过D，我决定去开D，发现是一个构造题，想到了一个大致的方向。这个时候ywh去上厕所了，我就和wsj说F的题意和方向。wsj听了之后觉得很有道理，然后ywh下机，我和wsj开始打表，wsj推出了规律，讨论了一下后，我开始写D。 D题代码很短，写完之后交上去的前一秒，wsj发现我还没有输出个数，我wa了一发，然后改输出的时候发现还有一个特判写的有问题，改了之后A了。 这个时候还剩两小时，wsj继续和ywh想B，我在认定E没法做之后，决定再开一题F。 F题是个图论，把题意简化之后和wsj确认了一下没有问题之后，继续往深的地方想，突然想到一个数组平均数最大的子集就是最大的数本身，我猜一定是选一条边就行了，上机开始码，然后也很顺利的wa了，发现关了同步流之后同时用了cin和printf，所以开了同步流又叫了一发，喜提wa+1。这个时候wsj发现了两条边的情况hack了我的思路。我继续想了一会发现好像不可能有超过两条边的情况，跑了一下随机数，发现随机不出来。ywh说B快出了，然后我就在旁边等。 过了一会之后ywh调完之后交上去，A了。 然后这个时候我上机开始改之前的代码，加上两条边的情况之后，交上去，wa+1。然后三个人开始找bug，然后发现少讨论了情况，改了之后，交上去，wa+1.再找bug，发现建图有问题，还有一些细节问题，交上去，A了。 到这里昆明站之旅其实就已经差不多结束了，再之后的半个小时里，我继续想了一会E，仍然没有什么思路（可能对苦练了这么久的字符串还是不能释怀），最后ywh在上机猜G题结论的时候，我和wsj已经沉浸在喜悦中了。 中间的插曲是因为在宿舍训练赛打习惯了，经常站起来走来走去被志愿者警告了。 ","date":"2022-04-18","objectID":"/posts/46thicpckunming/:0:6","tags":["Notes"],"title":"退役记\u0026\u0026icpc昆明站游记","uri":"/posts/46thicpckunming/"},{"categories":["2022/4"],"content":"赛后\u0026\u0026总结 我还依稀记得，在我初三的时候，晚上我的一个好朋友在用手机跟妹子聊天，而我在用手机看OI和ACM的题目。自习课上我的那个朋友跟妹子一起学习，而我则翘课想去机房，有时候机房老师不让我去，我就跑去 天台用草稿纸想题目。中午的时候我的那个朋友去跟妹子一起吃饭了，而我在机房里啃泡面。周末他们出去看电影逛公园，我就在电脑前面刷出一整版的WA。就这样日子悠悠的过去，我的朋友如今跟妹子过的很幸福，不过我觉得我跟我的电脑过的要更加幸福（笑）。 那时我还年轻，也想不到以后会怎么样，就是想要呆在机房里，为了做出题目这样纯粹的感动而活下去。一晃五年过去了，有如白驹过隙，Android从1.0到了4.3，srm从424到了594。从我AC第一道A+B以来，世界已经变了太多，曾经的感动和梦想似乎也随风而去。然而我心中却始终回荡着几天后AC 的欢呼声，差几秒钟提交的捶桌声，比赛失利的呜咽声，以及永恒的机房主题—-键盘声。 我还记得很久以前有人跟我说的话，自己选择的路，跪着也要走完。朋友们，虽然这个世界日益浮躁起来，只要能够为了当时纯粹的梦想和感动坚持努力下去，不管其它人怎么样，我们也能够保持自己的本色走下去。 曾经因为陈立杰的这段话感动不已，也因梦想与感动坚持到今天。直到今天终于要卸下ACMer的头衔了，回想到做出A+B仿佛还在昨天。 曾经立下的flag到现在貌似也没有几个做到了，大一立下豪言壮语要拿下金牌，大二希望能在退役前上个紫名…不过这些都已经不再重要了，重要的是这一路上最后没有留下后悔。 曾经的纠结，曾经的失落，曾经的愤恨到现在也释然了。 心中百感交集，回想起走过的路总能脑补出乔峰大战聚贤庄、关羽千里走单骑一样壮怀激烈的画面，但其实无非是三个人对着wa了的代码抓耳挠腮的找bug罢了。 一路走来，感谢塔子哥最初的发掘，感谢队友——我愿称之南华第一dp手ywh和关键时候总能推出正确思路的wsj，以及感谢颖子哥在我失落的时候、在我自闭的时候给我的支持和鼓励。 这一段路暂且到此，走向人生下一个路口了… ","date":"2022-04-18","objectID":"/posts/46thicpckunming/:0:7","tags":["Notes"],"title":"退役记\u0026\u0026icpc昆明站游记","uri":"/posts/46thicpckunming/"},{"categories":["2022/1"],"content":"传送门 ","date":"2022-01-10","objectID":"/posts/gym103446h/:0:0","tags":["gym","Kruskal reconstruction tree","binary lifting on tree"],"title":"2021ICPC区域赛上海站 H Life is a Game","uri":"/posts/gym103446h/"},{"categories":["2022/1"],"content":"题意 $n$个点，$m$条边，每个点具有点权$a_i$，每条边具有边权$w_i$，$q$次询问 询问当起点为$x$，且具备初始能力$k$时，能获得的最大能力值（当到达点$i$时，能力值$k$增加$a_i$，当$k\u003ew_i$时可以通过该边） ","date":"2022-01-10","objectID":"/posts/gym103446h/:0:1","tags":["gym","Kruskal reconstruction tree","binary lifting on tree"],"title":"2021ICPC区域赛上海站 H Life is a Game","uri":"/posts/gym103446h/"},{"categories":["2022/1"],"content":"思路 不难想到如果从某个起点能到达点$i$，那么通过最小生成树上的路径，该点也一定能到达点$i$，因此我们从最小生成树的角度来思考这个题 这里引入一个数据结构Kruskal重构树，构造过程如下 我们在Kruskal最小生成树的过程中，当我们要合并点$u$和点$v$时： 新建节点$node$，$fa[node]=node$ $fa[u]=node$，$ fa[v]=node$ 在新图中将$node$和$u$与$node$和$v$连边 通过这样最小重构树会构造一个大根堆，且所有的叶子结点都是原图中的点 那么，如果我们可以从一个叶子结点到达一个非叶子结点，由大根堆的性质，我们就可以到达以该非叶子结点为根的子树下的所有结点 那么我们就只需要在预处理所有子树能获得的能力值之和后，通过树上倍增，查找到能走到的最浅的一颗子树即可 ","date":"2022-01-10","objectID":"/posts/gym103446h/:0:2","tags":["gym","Kruskal reconstruction tree","binary lifting on tree"],"title":"2021ICPC区域赛上海站 H Life is a Game","uri":"/posts/gym103446h/"},{"categories":["2022/1"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int maxn=2e5+5; int n,m,q; int a[maxn]; int fa[maxn\u003c\u003c1]; struct edge{ int u,v,w; }e[maxn]; vector\u003cint\u003e g[maxn\u003c\u003c1]; int root; int w[maxn]; ll sum[maxn]; int vis[maxn],f[maxn][22]; ll num[maxn][22]; bool cmp(edge a,edge b){return a.w\u003cb.w;} void init(){for(int i=0;i\u003c=n;i++)fa[i]=i;} int fnd(int u){return fa[u]=fa[u]==u?u:fnd(fa[u]);} void kruskaltree(){ init(); root=n; sort(e+1,e+1+m,cmp); for(int i=1;i\u003c=m;i++){ int fu=fnd(e[i].u),fv=fnd(e[i].v); if(fu!=fv){ root++; g[fu].push_back(root); g[fv].push_back(root); g[root].push_back(fu); g[root].push_back(fv); w[root]=e[i].w; fa[fu]=fa[fv]=fa[root]=root; } } } void dfs(int u,int fa){ sum[u]=a[u]; for(int v:g[u]){ if(v==fa)continue; dfs(v,u); sum[u]+=sum[v]; f[v][0]=u; } } void bfs(){ queue\u003cint\u003e q; q.push(root); vis[root]=1; while(q.size()){ int u=q.front(); q.pop(); num[u][0]=w[f[u][0]]-sum[u]; for(int i=1;i\u003c=20;i++){ f[u][i]=f[f[u][i-1]][i-1]; num[u][i]=max(num[u][i-1],num[f[u][i-1]][i-1]); } for(int v:g[u]){ if(vis[v])continue; q.push(v); vis[v]=1; } } } int query(int u,int k){ for(int i=20;i\u003e=0;i--){ if(f[u][i]\u0026\u0026num[u][i]\u003c=k)u=f[u][i]; } return sum[u]; } inline void solve(){ cin\u003e\u003en\u003e\u003em\u003e\u003eq; for(int i=1;i\u003c=n;i++)cin\u003e\u003ea[i]; for(int i=1;i\u003c=m;i++)cin\u003e\u003ee[i].u\u003e\u003ee[i].v\u003e\u003ee[i].w; kruskaltree(); dfs(root,0); bfs(); while(q--){ int u,k; cin\u003e\u003eu\u003e\u003ek; cout\u003c\u003ck+query(u,k)\u003c\u003cendl; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--)solve(); return 0; } ","date":"2022-01-10","objectID":"/posts/gym103446h/:0:3","tags":["gym","Kruskal reconstruction tree","binary lifting on tree"],"title":"2021ICPC区域赛上海站 H Life is a Game","uri":"/posts/gym103446h/"},{"categories":["2022/1"],"content":"小结 之前一直以为Kruskal重构树就是最小生成树，今天一查直接惊了…训练的时候已经想到了最小生成树也想到了倍增，就差Kruskal重构树这个知识点了，算是只差临门一脚了，过于可惜了 ","date":"2022-01-10","objectID":"/posts/gym103446h/:0:4","tags":["gym","Kruskal reconstruction tree","binary lifting on tree"],"title":"2021ICPC区域赛上海站 H Life is a Game","uri":"/posts/gym103446h/"},{"categories":["2021/11"],"content":"传送门 ","date":"2021-11-30","objectID":"/posts/cf1574d/:0:0","tags":["codeforces","bfs"],"title":"Codeforces 1574D The Strongest Build","uri":"/posts/cf1574d/"},{"categories":["2021/11"],"content":"题意 给$n$个数组，从每个数组中选出一个数称为$build$，要求选择出的$build$的和最大并且不能选择被禁止的$build$ ","date":"2021-11-30","objectID":"/posts/cf1574d/:0:1","tags":["codeforces","bfs"],"title":"Codeforces 1574D The Strongest Build","uri":"/posts/cf1574d/"},{"categories":["2021/11"],"content":"思路 优先队列+bfs 当选出的$build$没有被禁止，直接输出即可 ","date":"2021-11-30","objectID":"/posts/cf1574d/:0:2","tags":["codeforces","bfs"],"title":"Codeforces 1574D The Strongest Build","uri":"/posts/cf1574d/"},{"categories":["2021/11"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; typedef long long ll; int n,m,ttt,d; vector\u003cint\u003e v[20]; set\u003cvector\u003cint\u003e\u003e st1,st2; vector\u003cint\u003e tmp; priority_queue\u003cpair\u003cint,vector\u003cint\u003e\u003e\u003e q; vector\u003cint\u003e now; inline void solve(){ cin\u003e\u003en; for(int i=0;i\u003cn;i++){ cin\u003e\u003em; for(int j=0;j\u003cm;j++){ cin\u003e\u003ettt; v[i].push_back(ttt); } tmp.push_back(m-1); } ll sum=0; for(int i=0;i\u003ctmp.size();i++)sum+=v[i][tmp[i]]; q.push(pair(sum,tmp)); st2.insert(tmp); cin\u003e\u003em; while(m--){ tmp.clear(); for(int i=0;i\u003cn;i++){ cin\u003e\u003ettt; ttt--; tmp.push_back(ttt); } st1.insert(tmp); } while(q.size()){ sum=q.top().first; now=q.top().second; q.pop(); if(!st1.count(now)){ for(int i:now)cout\u003c\u003ci+1\u003c\u003c\" \"; return ; } for(int i=0;i\u003cn;i++){ if(now[i]-1\u003e=0){ d=sum-v[i][now[i]]+v[i][now[i]-1]; now[i]--; if(!st2.count(now)){ st2.insert(now); q.push(pair(d,now)); } now[i]++; } } } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-11-30","objectID":"/posts/cf1574d/:0:3","tags":["codeforces","bfs"],"title":"Codeforces 1574D The Strongest Build","uri":"/posts/cf1574d/"},{"categories":["2021/11"],"content":"小结 很恶心的一道搜索题，思路很简单，但是实现起来很复杂 ","date":"2021-11-30","objectID":"/posts/cf1574d/:0:4","tags":["codeforces","bfs"],"title":"Codeforces 1574D The Strongest Build","uri":"/posts/cf1574d/"},{"categories":["2021/11"],"content":"传送门 ","date":"2021-11-29","objectID":"/posts/cf1609e/:0:0","tags":["codeforces","segment tree","dp"],"title":"Codeforces 1609E William The Oblivious","uri":"/posts/cf1609e/"},{"categories":["2021/11"],"content":"题意 给一个长度为$n$只包含$a,b,c$的字符串，对串进行$m$次操作 每一次操作为将位置$pos$处的字符改为字符$c$，并输出此时最少需要替换多少个字符使得串中不包含子序列$abc$ ","date":"2021-11-29","objectID":"/posts/cf1609e/:0:1","tags":["codeforces","segment tree","dp"],"title":"Codeforces 1609E William The Oblivious","uri":"/posts/cf1609e/"},{"categories":["2021/11"],"content":"思路 首先对于这种带修改、无删除操作的问题，我们不难想到用线段树来维护信息 对于这个问题，我们不妨考虑将$abc$拆分。 我们首先考虑分别使区间中不包含子序列$a,b,c$，很显然，分别维护$a,b,c$的个数即可. 然后我们需要思考如何使区间中不包含子序列$ab,bc$，这里我们用动态规划的思想来思考这个问题，如果我们要通过最小的操作使得区间$p$中没有子序列$ab$，我们要么使左子区间中不包含$a$并且右子区间中不包含$ab$，要么使左子区间中不包含$ab$并且右子区间中不包含$b$，令$pl=p2,pr=p2+1$状态转移方程为$tree[p].ab=min(tree[pl].a+tree[pr].ab,tree[pl].ab+tree[pr].b)$ 最后我们考虑如何使区间中不包含子序列$abc$，同样是利用动态规划的思想，我们有三种策略，我们要么使左子区间中不包含$a$并且右子区间中不包含$abc$，要么使左子区间中不包含$abc$并且右子区间中不包含$c$,要么使左子区间中不包含$ab$并且右子区间中不包含$bc$，状态转移方程为$tree[p].abc=min({tree[pl].a+tree[pr].abc,tree[pl].abc+tree[pr].c,tree[pr].abc,tree[pl].ab+tree[pr].bc})$ ","date":"2021-11-29","objectID":"/posts/cf1609e/:0:2","tags":["codeforces","segment tree","dp"],"title":"Codeforces 1609E William The Oblivious","uri":"/posts/cf1609e/"},{"categories":["2021/11"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' const int maxn=2e5+5; int n,m; string s; struct node{ int a,b,c,ab,bc,abc; node(){a=b=c=ab=bc=abc=0;} node(int _a,int _b,int _c){ a=_a; b=_b; c=_c; ab=bc=abc=0; } }; struct seg{ node v; int l,r; }tree[maxn\u003c\u003c2]; node merge(node u,node v){ node res(u.a+v.a,u.b+v.b,u.c+v.c); res.ab=min(u.a+v.ab,u.ab+v.b); res.bc=min(u.b+v.bc,u.bc+v.c); res.abc=min({u.a+v.abc,u.abc+v.c,u.ab+v.bc}); return res; } inline void pushup(int p){ tree[p].v=merge(tree[p\u003c\u003c1].v,tree[p\u003c\u003c1|1].v); } void build(int l,int r,int p=1){ tree[p].l=l,tree[p].r=r; if(tree[p].l==tree[p].r){ tree[p].v=node(s[l]=='a',s[l]=='b',s[l]=='c'); return ; } int mid=(tree[p].l+tree[p].r)\u003e\u003e1; build(l,mid,p\u003c\u003c1); build(mid+1,r,p\u003c\u003c1|1); pushup(p); } void change(int k,char c,int p=1){ if(tree[p].l==tree[p].r){ tree[p].v=node(c=='a',c=='b',c=='c'); return ; } int mid=(tree[p].l+tree[p].r)\u003e\u003e1; if(k\u003c=mid)change(k,c,p\u003c\u003c1); if(k\u003emid)change(k,c,p\u003c\u003c1|1); pushup(p); } inline void solve(){ cin\u003e\u003en\u003e\u003em; cin\u003e\u003es; s=\"#\"+s; build(1,n); int pos; char c; while(m--){ cin\u003e\u003epos\u003e\u003ec; change(pos,c); cout\u003c\u003ctree[1].v.abc\u003c\u003cendl; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-11-29","objectID":"/posts/cf1609e/:0:3","tags":["codeforces","segment tree","dp"],"title":"Codeforces 1609E William The Oblivious","uri":"/posts/cf1609e/"},{"categories":["2021/11"],"content":"小结 比赛的时候想到线段树但是不知道怎么维护，最后看到题解的时候不经感叹真是太妙了 找了很久的题解最后是看一篇韩文博客看明白的，代码中很多写法都是借鉴了这位博主 这里贴一下原题解的博客地址 ","date":"2021-11-29","objectID":"/posts/cf1609e/:0:4","tags":["codeforces","segment tree","dp"],"title":"Codeforces 1609E William The Oblivious","uri":"/posts/cf1609e/"},{"categories":["2021/11"],"content":"传送门 ","date":"2021-11-16","objectID":"/posts/gym101955e/:0:0","tags":["gym","segment tree","Chebyshev distance","Manhattan distance"],"title":"2018ICPC区域赛沈阳站 E The Kouga Ninja Scrolls","uri":"/posts/gym101955e/"},{"categories":["2021/11"],"content":"题意 给出$n$个忍者，每个忍者属于帮派$c_i$，位置$(x_i,y_i)$，满足以下操作 将忍者$k$的位置移至$(x_k+x,y_k+y)$ 将忍者$k$所属的帮派改为$c$ 查询区间$[l,r]$内的忍者中分属于不同帮派的忍者的曼哈顿距离的最大值 ","date":"2021-11-16","objectID":"/posts/gym101955e/:0:1","tags":["gym","segment tree","Chebyshev distance","Manhattan distance"],"title":"2018ICPC区域赛沈阳站 E The Kouga Ninja Scrolls","uri":"/posts/gym101955e/"},{"categories":["2021/11"],"content":"思路 曼哈顿距离与切比雪夫距离： 曼哈顿距离：$dis=|x_1-x_2|+|y_1-y_2|$ 切比雪夫距离：$dis=max(|x_1-x_2|,|y_1-y_2|)$ 将$(x,y)$改为$(x+y,x-y)$，原坐标轴下的曼哈顿距离等于新坐标轴下的切比雪夫距离，将$(x,y)$改为$((x+y)/2,(x-y)/2)$，原坐标轴下的切比雪夫距离等于新坐标轴下的曼哈顿距离 利用两棵线段树分别维护$x$和$y$坐标 因为要分属于不同帮派，所以在线段树中维护最大值、次大值、最小值、次小值以及这些值所属的帮派（次大值和次小值的帮派信息可以不用维护），需要使最大值和次大值、最小值和次小值属于不同的帮派 在查询时，如果最大值和最小值所属帮派相同则输出最大值和次小值之差与次大值和最小值之差中更大的一个，否则则直接输出最大值与最小值之差即可 要注意的是，在查询操作时，同样需要对返回值维护最大与次大、最小与次小的不同帮派，我的做法是在写pushup()时传入三个参数，使得pushup()的使用更加灵活 ","date":"2021-11-16","objectID":"/posts/gym101955e/:0:2","tags":["gym","segment tree","Chebyshev distance","Manhattan distance"],"title":"2018ICPC区域赛沈阳站 E The Kouga Ninja Scrolls","uri":"/posts/gym101955e/"},{"categories":["2021/11"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define fi first #define se second typedef long long ll; typedef pair\u003cll,ll\u003e P; const ll inf=1e19; const int maxn=5e5+5; int n,m; ll x,y,c,k,l,r; struct node{ int l,r; P mx1,mx2,mn1,mn2; }tree[2][maxn\u003c\u003c2]; ll a[2][maxn]; int b[maxn]; int kase; void f1(ll\u0026 x,ll\u0026 y){ ll a=x+y,b=x-y; x=a,y=b; } void f2(ll\u0026 x,ll\u0026 y){ ll a=(x+y)/2,b=(x-y)/2; x=a,y=b; } void pushup(int p,int pl,int pr){ node tmp; for(int tr=0;tr\u003c2;tr++){ if(tree[tr][pl].mx1.se==tree[tr][pr].mx1.se){ tmp.mx1=max(tree[tr][pl].mx1,tree[tr][pr].mx1); tmp.mx2=max(tree[tr][pl].mx2,tree[tr][pr].mx2); }else if(tree[tr][pl].mx1.fi\u003etree[tr][pr].mx1.fi){ tmp.mx1=tree[tr][pl].mx1; tmp.mx2=max(tree[tr][pl].mx2,tree[tr][pr].mx1); }else{ tmp.mx1=tree[tr][pr].mx1; tmp.mx2=max(tree[tr][pl].mx1,tree[tr][pr].mx2); } if(tree[tr][pl].mn1.se==tree[tr][pr].mn1.se){ tmp.mn1=min(tree[tr][pl].mn1,tree[tr][pr].mn1); tmp.mn2=min(tree[tr][pl].mn2,tree[tr][pr].mn2); }else if(tree[tr][pl].mn1.fi\u003ctree[tr][pr].mn1.fi){ tmp.mn1=tree[tr][pl].mn1; tmp.mn2=min(tree[tr][pl].mn2,tree[tr][pr].mn1); }else{ tmp.mn1=tree[tr][pr].mn1; tmp.mn2=min(tree[tr][pl].mn1,tree[tr][pr].mn2); } tmp.l=tree[tr][p].l; tmp.r=tree[tr][p].r; tree[tr][p]=tmp; } } void init(int p){ for(int tr=0;tr\u003c2;tr++){ tree[tr][p].mx1.fi=-inf; tree[tr][p].mn1.fi=inf; tree[tr][p].mx1.se=tree[tr][p].mn1.se=0; tree[tr][p].mx2.fi=-inf; tree[tr][p].mn2.fi=inf; tree[tr][p].mx2.se=tree[tr][p].mn2.se=0; } } void build(int l,int r,int p=1){ tree[0][p].l=l,tree[0][p].r=r; tree[1][p].l=l,tree[1][p].r=r; if(tree[0][p].l==tree[0][p].r){ for(int tr=0;tr\u003c2;tr++){ tree[tr][p].mx1.fi=tree[tr][p].mn1.fi=a[tr][l]; tree[tr][p].mx1.se=tree[tr][p].mn1.se=b[l]; tree[tr][p].mx2.fi=-inf; tree[tr][p].mn2.fi=inf; tree[tr][p].mx2.se=tree[tr][p].mn2.se=0; } return ; } int mid=(tree[0][p].l+tree[0][p].r)\u003e\u003e1; build(l,mid,p\u003c\u003c1); build(mid+1,r,p\u003c\u003c1|1); pushup(p,p\u003c\u003c1,p\u003c\u003c1|1); } void change1(int k,int x,int y,int p=1){ if(tree[0][p].l==tree[0][p].r){ ll xx=tree[0][p].mx1.fi; ll yy=tree[1][p].mx1.fi; f2(xx,yy); xx+=x,yy+=y; f1(xx,yy); tree[0][p].mx1.fi=tree[0][p].mn1.fi=xx; tree[1][p].mx1.fi=tree[1][p].mn1.fi=yy; return ; } int mid=(tree[0][p].l+tree[0][p].r)\u003e\u003e1; if(k\u003c=mid)change1(k,x,y,p\u003c\u003c1); else change1(k,x,y,p\u003c\u003c1|1); pushup(p,p\u003c\u003c1,p\u003c\u003c1|1); } void change2(int k,int c,int p=1){ if(tree[0][p].l==tree[0][p].r){ tree[0][p].mx1.se=tree[0][p].mn1.se=c; tree[1][p].mx1.se=tree[1][p].mn1.se=c; return ; } int mid=(tree[0][p].l+tree[0][p].r)\u003e\u003e1; if(k\u003c=mid)change2(k,c,p\u003c\u003c1); else change2(k,c,p\u003c\u003c1|1); pushup(p,p\u003c\u003c1,p\u003c\u003c1|1); } void query(int l,int r,int p=1){ if(l\u003c=tree[0][p].l\u0026\u0026r\u003e=tree[0][p].r)return pushup(0,0,p); int mid=(tree[0][p].l+tree[0][p].r)\u003e\u003e1; if(l\u003c=mid)query(l,r,p\u003c\u003c1); if(r\u003emid)query(l,r,p\u003c\u003c1|1); } ll getmax(int l,int r){ init(0); query(l,r); ll res[2]; for(int tr=0;tr\u003c2;tr++){ if(tree[tr][0].mx1.se!=tree[tr][0].mn1.se)res[tr]=abs(tree[tr][0].mx1.fi-tree[tr][0].mn1.fi); else if(tree[tr][0].mx2.se\u0026\u0026tree[tr][0].mn2.se)res[tr]=max(abs(tree[tr][0].mx1.fi-tree[tr][0].mn2.fi),abs(tree[tr][0].mx2.fi-tree[tr][0].mn1.fi)); else res[tr]=0; } return max(res[0],res[1]); } inline void solve(){ cout\u003c\u003c\"Case #\"\u003c\u003c++kase\u003c\u003c\":\"\u003c\u003cendl; cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++){ cin\u003e\u003ex\u003e\u003ey\u003e\u003eb[i]; f1(x,y); a[0][i]=x,a[1][i]=y; } build(1,n); int opt; while(m--){ cin\u003e\u003eopt; if(opt==1){ cin\u003e\u003ek\u003e\u003ex\u003e\u003ey; change1(k,x,y); }else if(opt==2){ cin\u003e\u003ek\u003e\u003ec; change2(k,c); }else{ cin\u003e\u003el\u003e\u003er; cout\u003c\u003cgetmax(l,r)\u003c\u003cendl; } } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-11-16","objectID":"/posts/gym101955e/:0:3","tags":["gym","segment tree","Chebyshev distance","Manhattan distance"],"title":"2018ICPC区域赛沈阳站 E The Kouga Ninja Scrolls","uri":"/posts/gym101955e/"},{"categories":["2021/11"],"content":"小结 这个线段树真的把我写麻了（写到生理反胃），为了压缩代码不择手段了属于是，另外就是学到了切比雪夫距离和曼哈顿距离的转化，在不易维护其中一个距离时，不妨可以考虑将其转化为另一个距离维护 ","date":"2021-11-16","objectID":"/posts/gym101955e/:0:4","tags":["gym","segment tree","Chebyshev distance","Manhattan distance"],"title":"2018ICPC区域赛沈阳站 E The Kouga Ninja Scrolls","uri":"/posts/gym101955e/"},{"categories":["2021/11"],"content":"传送门 ","date":"2021-11-16","objectID":"/posts/gym101955g/:0:0","tags":["gym","brute force"],"title":"2018ICPC区域赛沈阳站 G Best ACMer Solves the Hardest Problem","uri":"/posts/gym101955g/"},{"categories":["2021/11"],"content":"题意 给一个二维平面内有$n$个点，满足以下操作： 在$(x,y)$处添加一个点，点权为$w$ 将$(x,y)$处的点删除 将所有与$(x,y)$距离为$k$的点的点权增加$w$ 查询所有与$(x,y)$距离为$k$的点的点权和 ","date":"2021-11-16","objectID":"/posts/gym101955g/:0:1","tags":["gym","brute force"],"title":"2018ICPC区域赛沈阳站 G Best ACMer Solves the Hardest Problem","uri":"/posts/gym101955g/"},{"categories":["2021/11"],"content":"思路 给1Gb内存，12秒，直接暴力就可以过了，$k\\leqslant 1e7$，预处理所有$k$值的坐标增量的情况 另外在初始化时提前记录所有的点，然后将存在点的位置初始化即可 ","date":"2021-11-16","objectID":"/posts/gym101955g/:0:2","tags":["gym","brute force"],"title":"2018ICPC区域赛沈阳站 G Best ACMer Solves the Hardest Problem","uri":"/posts/gym101955g/"},{"categories":["2021/11"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define fi first #define se second typedef long long ll; typedef pair\u003cint,int\u003e Pii; const int maxn=6e3+5; const int maxm=1e7+7; int n,m; int mp[maxn][maxn]; vector\u003cPii\u003e pre[maxm]; int dx[]={1,1,-1,-1}; int dy[]={1,-1,-1,1}; set\u003cPii\u003e s; vector\u003cPii\u003e ss; int kase; void init(){ for(int i=0;i\u003c=6000;i++){ for(int j=0;j\u003c=6000;j++){ if(i*i+j*j\u003c=1e7)pre[i*i+j*j].push_back(Pii(i,j)); else break; } } } bool f(int x,int y){ return x\u003e0\u0026\u0026x\u003c=6000\u0026\u0026y\u003e0\u0026\u0026y\u003c=6000; } inline void solve(){ cout\u003c\u003c\"Case #\"\u003c\u003c++kase\u003c\u003c\":\"\u003c\u003cendl; cin\u003e\u003en\u003e\u003em; ss.clear(); ll x,y,w,k,opt; ll res=0; for(int i=1;i\u003c=n;i++){ cin\u003e\u003ex\u003e\u003ey\u003e\u003ew; mp[x][y]=w; ss.push_back(Pii(x,y)); } while(m--){ cin\u003e\u003eopt\u003e\u003ex\u003e\u003ey; x=(x+res)%6000+1; y=(y+res)%6000+1; if(opt==1){ cin\u003e\u003ew; mp[x][y]=w; ss.push_back(Pii(x,y)); }else if(opt==2)mp[x][y]=0; else if(opt==3){ cin\u003e\u003ek\u003e\u003ew; s.clear(); for(int j=0;j\u003cpre[k].size();j++){ for(int p=0;p\u003c4;p++){ int xx=x+dx[p]*pre[k][j].fi; int yy=y+dy[p]*pre[k][j].se; if(f(xx,yy)\u0026\u0026mp[xx][yy]\u0026\u0026!s.count(Pii(xx,yy))){ mp[xx][yy]+=w; s.insert(Pii(xx,yy)); } } } }else{ res=0; cin\u003e\u003ek; s.clear(); for(int j=0;j\u003cpre[k].size();j++){ for(int p=0;p\u003c4;p++){ int xx=x+dx[p]*pre[k][j].fi; int yy=y+dy[p]*pre[k][j].se; if(f(xx,yy)\u0026\u0026mp[xx][yy]\u0026\u0026!s.count(Pii(xx,yy))){ res+=mp[xx][yy]; s.insert(Pii(xx,yy)); } } } cout\u003c\u003cres\u003c\u003cendl; } } for(auto i:ss){ mp[i.fi][i.se]=0; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; init(); while(__--){ solve(); } return 0; } ","date":"2021-11-16","objectID":"/posts/gym101955g/:0:3","tags":["gym","brute force"],"title":"2018ICPC区域赛沈阳站 G Best ACMer Solves the Hardest Problem","uri":"/posts/gym101955g/"},{"categories":["2021/11"],"content":"小结 训练的时候看错题意以为要统计圆内的所有点的点权和，死活没想到有什么数据结构可以维护这么大的数据，最后发现居然是读错题，无语 总结下来就是还是要更仔细的读题，对时间复杂度的分析还要更加细致 ","date":"2021-11-16","objectID":"/posts/gym101955g/:0:4","tags":["gym","brute force"],"title":"2018ICPC区域赛沈阳站 G Best ACMer Solves the Hardest Problem","uri":"/posts/gym101955g/"},{"categories":["2021/11"],"content":"传送门 ","date":"2021-11-09","objectID":"/posts/acwing1063/:0:0","tags":["acwing","Splay"],"title":"Acwing 1063 永无乡","uri":"/posts/acwing1063/"},{"categories":["2021/11"],"content":"题意 给出$n$个岛，每个岛有权值$a[i]$，两种操作： 连接两座岛 询问岛$x$所在的联通块中权值第$k$小的岛的编号 ","date":"2021-11-09","objectID":"/posts/acwing1063/:0:1","tags":["acwing","Splay"],"title":"Acwing 1063 永无乡","uri":"/posts/acwing1063/"},{"categories":["2021/11"],"content":"思路 首先开$n$棵Splay，在结点中记录该结点归属于哪一棵Splay的信息$bl$，然后启发式合并Splay（把结点数小的Splay中的结点插入到大的Splay中），显然这样操作最后的复杂度是$O(nlognlog)$（说白了我也不会证） ","date":"2021-11-09","objectID":"/posts/acwing1063/:0:2","tags":["acwing","Splay"],"title":"Acwing 1063 永无乡","uri":"/posts/acwing1063/"},{"categories":["2021/11"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' const int maxn=2e5+5; int n,m,q; char opt[3]; int a[maxn]; struct node{ int ch[2],fa,size,bl; int val; }tree[maxn]; int root[maxn]; inline void pushup(int u){ tree[u].size=tree[tree[u].ch[0]].size+tree[tree[u].ch[1]].size+1; } inline void rotate(int x){ int y=tree[x].fa,z=tree[y].fa; int k=tree[y].ch[1]==x; tree[z].ch[tree[z].ch[1]==y]=x,tree[x].fa=z; tree[y].ch[k]=tree[x].ch[k^1],tree[tree[x].ch[k^1]].fa=y; tree[x].ch[k^1]=y,tree[y].fa=x; pushup(y),pushup(x); } void splay(int x,int k,int tr){ while(tree[x].fa!=k){ int y=tree[x].fa,z=tree[y].fa; if(z!=k){ if((tree[y].ch[1]==x)^(tree[z].ch[1]==y))rotate(x); else rotate(y); } rotate(x); } if(!k)root[tr]=x; } void insert(int u,int tr){ int fa=0,v=root[tr]; while(v)fa=v,v=tree[v].ch[tree[u].val\u003etree[v].val]; if(fa)tree[fa].ch[tree[u].val\u003etree[fa].val]=u; tree[u].ch[0]=tree[u].ch[1]=0; tree[u].fa=fa; tree[u].size=1; tree[u].bl=tr; splay(u,0,tr); } void dfs(int u,int tr){ if(tree[u].ch[0])dfs(tree[u].ch[0],tr); if(tree[u].ch[1])dfs(tree[u].ch[1],tr); insert(u,tr); } void init(int n){ for(int i=1;i\u003c=n;i++){ root[i]=i; tree[i].size=1; tree[i].val=a[i]; tree[i].bl=i; } } void merge(int u,int v){ int x=tree[u].bl,y=tree[v].bl; if(x==y)return ; tree[root[x]].size\u003ctree[root[y]].size?(dfs(root[x],y),root[x]=0):(dfs(root[y],x),root[y]=0); } int get_k(int u,int rnk){ while(1){ if(tree[tree[u].ch[0]].size\u003e=rnk)u=tree[u].ch[0]; else if(tree[tree[u].ch[0]].size+1==rnk)return u; else rnk-=tree[tree[u].ch[0]].size+1,u=tree[u].ch[1]; } } inline void solve(){ int u,v; scanf(\"%d %d\",\u0026n,\u0026m); for(int i=1;i\u003c=n;i++)scanf(\"%d\",\u0026a[i]); init(n); while(m--){ scanf(\"%d %d\",\u0026u,\u0026v); merge(u,v); } scanf(\"%d\",\u0026q); while(q--){ scanf(\"%s %d %d\",\u0026opt,\u0026u,\u0026v); if(opt[0]=='B')merge(u,v); else{ if(tree[root[tree[u].bl]].size\u003cv)puts(\"-1\"); else printf(\"%d\\n\",get_k(root[tree[u].bl],v)); } } } int main(){ int __=1; while(__--){ solve(); } return 0; } ","date":"2021-11-09","objectID":"/posts/acwing1063/:0:3","tags":["acwing","Splay"],"title":"Acwing 1063 永无乡","uri":"/posts/acwing1063/"},{"categories":["2021/11"],"content":"小结 思路几乎是看完题就想到了，实现的过程真是一言难尽，各种小错误不断，从dfs插入的顺序不对，到递归版查找第$k$大没有返回值，然后到Splay的旋转向上更新写反，每一个错误都是很不应该的，修bug足足修了两天，实在是对自己的状态担忧 ","date":"2021-11-09","objectID":"/posts/acwing1063/:0:4","tags":["acwing","Splay"],"title":"Acwing 1063 永无乡","uri":"/posts/acwing1063/"},{"categories":["2021/10"],"content":"传送门 ","date":"2021-10-27","objectID":"/posts/cf1582e/:0:0","tags":["codeforces","dp"],"title":"Codeforces 1582E Pchelyonok and Segments","uri":"/posts/cf1582e/"},{"categories":["2021/10"],"content":"题意 将一个数组划分成$k$个子段，对于第$i$个子段和第$i+1$个子段，需要满足子段$i$的元素个数为$n-i+1$，子段$n-(i+1)+1$的元素个数为$i+1$，并且子段$i$的元素之和小于子段$i+1$的元素之和，输出$k$的最大值 ","date":"2021-10-27","objectID":"/posts/cf1582e/:0:1","tags":["codeforces","dp"],"title":"Codeforces 1582E Pchelyonok and Segments","uri":"/posts/cf1582e/"},{"categories":["2021/10"],"content":"思路 首先不难看出长度为$n$的数组，$k$的取值满足$(k+1)*k/2\\leqslant n$ 我们将整个数组倒置，此时第$i$个子段的长度为$i$，同时预处理出前缀和$pre$ 我们令$dp[i][j]$代表前$i$个元素中，子段数量为$k$的情况中的第$k$个子段的最大值，如果不可能则为$0$ 所以状态转移方程如下： $dp[i][j]=dp[i-1][j]$ 当$pre[i]-pre[i-j]$或者$j=1$时,$dp[i][j]=max(dp[i][j],pre[i]-pre[i-j])$ ","date":"2021-10-27","objectID":"/posts/cf1582e/:0:2","tags":["codeforces","dp"],"title":"Codeforces 1582E Pchelyonok and Segments","uri":"/posts/cf1582e/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; typedef long long ll; const int maxn=1e5+5; const int maxm=450; int n,m; int a[maxn]; ll pre[maxn],st[maxn]; ll dp[maxn][maxm]; void init(){ for(int i=1;i\u003c=500;i++)st[i]=st[i-1]+i; } ll sub(int l,int r){ return pre[r]-pre[l-1]; } inline void solve(){ cin\u003e\u003en; m= upper_bound(st,st+500,n)-st-1; for(int i=n;i\u003e0;i--)cin\u003e\u003ea[i]; for(int i=1;i\u003c=n;i++)pre[i]=pre[i-1]+a[i]; for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=m;j++){ if(i\u003cst[j])dp[i][j]=0; else{ dp[i][j]=dp[i-1][j]; if(j==1||sub(i-j+1,i)\u003cdp[i-j][j-1])dp[i][j]=max(dp[i][j],sub(i-j+1,i)); } } } for(int i=m;i\u003e0;i--){ if(dp[n][i]!=0){ cout\u003c\u003ci\u003c\u003cendl; return ; } } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; init(); while(__--){ solve(); } return 0; } ","date":"2021-10-27","objectID":"/posts/cf1582e/:0:3","tags":["codeforces","dp"],"title":"Codeforces 1582E Pchelyonok and Segments","uri":"/posts/cf1582e/"},{"categories":["2021/10"],"content":"小结 dp苦手，大大小小的bug改了一天 ","date":"2021-10-27","objectID":"/posts/cf1582e/:0:4","tags":["codeforces","dp"],"title":"Codeforces 1582E Pchelyonok and Segments","uri":"/posts/cf1582e/"},{"categories":["2021/10"],"content":"传送门 ","date":"2021-10-26","objectID":"/posts/cf1602d/:0:0","tags":["codeforces","bfs"],"title":"Codeforces 1602D Frog Traveler","uri":"/posts/cf1602d/"},{"categories":["2021/10"],"content":"题意 一只青蛙在井底初始位置为$n$，想跳到地面（地面为$0$），当青蛙在$i$时，可以向上跳$0～a[i]$任意高度，当青蛙跳到位置$j$时，会向下滑$b[i]$，求跳至地面最少需要几步，并输出路径 ","date":"2021-10-26","objectID":"/posts/cf1602d/:0:1","tags":["codeforces","bfs"],"title":"Codeforces 1602D Frog Traveler","uri":"/posts/cf1602d/"},{"categories":["2021/10"],"content":"思路 显然当青蛙想去往位置$j$时，其必须去到位置$i$，位置$i$满足$i+b[i]=j$，可以建立两个数组，$hua[i]=j$，$yuan[j]=i$，在bfs中我们只考虑最后滑到的位置 首先我们考虑裸bfs，对于位置$i$可以到达$hua[i-a[i],i-a[i]+1…i-1,i]$，由于边权相等，所以最短路中每一个点最多只会被访问一次 但是当我们以这种方式bfs时，对于位置$i$和位置$j$，$hua[max(i-a[i],j-a[j])…min(i,j)]$会被重复判断，因此我们在bfs的过程中记录位置$r$为我们以经访问过的最小的访问过的值，即对于位置$i$我们只需要判断$hua[i-a[i],r]$，然后更新$r=min(r,i-a[i]-1)$ ","date":"2021-10-26","objectID":"/posts/cf1602d/:0:2","tags":["codeforces","bfs"],"title":"Codeforces 1602D Frog Traveler","uri":"/posts/cf1602d/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=3e5+5; int n,m; int a[maxn],b[maxn]; int fa[maxn]; int hua[maxn]; int yuan[maxn]; bool vis[maxn]; vector\u003cint\u003e ans; inline void solve(){ scanf(\"%d\",\u0026n); n++; hua[n]=n; for(int i=2;i\u003c=n;i++)scanf(\"%d\",\u0026a[i]); for(int i=2;i\u003c=n;i++)scanf(\"%d\",\u0026b[i]); queue\u003cint\u003e q; fa[1]=-1; fa[n]=n; yuan[n]=n; hua[n]=n; vis[n]=1; q.push(n); int r=n-1; while(q.size()){ int t=q.front(); q.pop(); int l=t-a[t]; for(int i=l;i\u003c=r;i++){ int p=i+b[i]; if(vis[p])continue; fa[p]=t; hua[i]=p; yuan[p]=i; vis[p]=1; q.push(p); } if(l\u003c=r)r=l-1; } if(fa[1]==-1){ puts(\"-1\"); return ; } int p=1; while(p!=n){ ans.push_back(p); p=hua[p]; p=fa[p]; p=yuan[p]; } printf(\"%d\\n\",(int)ans.size()); for(int i=(int)ans.size()-1;i\u003e=0;i--)printf(\"%d \",ans[i]-1); puts(\"\"); } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-26","objectID":"/posts/cf1602d/:0:3","tags":["codeforces","bfs"],"title":"Codeforces 1602D Frog Traveler","uri":"/posts/cf1602d/"},{"categories":["2021/10"],"content":"总结 很简单的题，但是打比赛的时候一度想到线段树优化建图，还是没有更多的从剪枝、思维的角度想问题 ","date":"2021-10-26","objectID":"/posts/cf1602d/:0:4","tags":["codeforces","bfs"],"title":"Codeforces 1602D Frog Traveler","uri":"/posts/cf1602d/"},{"categories":["2021/10"],"content":"传送门 ","date":"2021-10-21","objectID":"/posts/cf438d/:0:0","tags":["codeforces","segment tree"],"title":"Codeforces 438D The Child and Sequence","uri":"/posts/cf438d/"},{"categories":["2021/10"],"content":"题意 构造一种数据结构满足以下三种操作 输出区间$[l,r]$所有元素的和 区间$[l,r]$中所有元素对$x$取模 将元素$a[i]$赋值$x$ ","date":"2021-10-21","objectID":"/posts/cf438d/:0:1","tags":["codeforces","segment tree"],"title":"Codeforces 438D The Child and Sequence","uri":"/posts/cf438d/"},{"categories":["2021/10"],"content":"思路 首先不难看出这是一个线段树 这里主要讨论第二种操作，对任意一个元素$a[i]$，如果$x\u003ea[i]$，则操作无意义。显然如果操作对$a[i]$有意义，则该操作会使得$a[i]$减半。所以$a[i]$最多修改$\\log a[i]$次，由此可见忽略无效操作然后暴力更新即可。 ","date":"2021-10-21","objectID":"/posts/cf438d/:0:2","tags":["codeforces","segment tree"],"title":"Codeforces 438D The Child and Sequence","uri":"/posts/cf438d/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; typedef long long ll; const int maxn=2e5+5; int n,m; int a[maxn]; struct node{ int l,r; ll mx,sum; }tree[maxn\u003c\u003c2]; void pushup(int p){ tree[p].sum=tree[p\u003c\u003c1].sum+tree[p\u003c\u003c1|1].sum; tree[p].mx=max(tree[p\u003c\u003c1].mx,tree[p\u003c\u003c1|1].mx); } void build(int l,int r,int p=1){ tree[p].l=l,tree[p].r=r; if(l==r){ tree[p].sum=tree[p].mx=a[l]; return ; } int mid=(tree[p].l+tree[p].r)\u003e\u003e1; build(l,mid,p\u003c\u003c1); build(mid+1,r,p\u003c\u003c1|1); pushup(p); } void Mod(int l,int r,int md,int p=1){ if(tree[p].mx\u003cmd)return ; if(tree[p].l==tree[p].r){ tree[p].mx%=md; tree[p].sum=tree[p].mx; return ; } int mid=(tree[p].l+tree[p].r)\u003e\u003e1; if(l\u003c=mid\u0026\u0026tree[p\u003c\u003c1].mx\u003e=md)Mod(l,r,md,p\u003c\u003c1); if(r\u003emid\u0026\u0026tree[p\u003c\u003c1|1].mx\u003e=md)Mod(l,r,md,p\u003c\u003c1|1); pushup(p); } void Set(int k,int val,int p=1){ if(tree[p].l==tree[p].r){ tree[p].mx=val; tree[p].sum=val; return ; } int mid=(tree[p].l+tree[p].r)\u003e\u003e1; if(k\u003c=mid)Set(k,val,p\u003c\u003c1); else Set(k,val,p\u003c\u003c1|1); pushup(p); } ll query(int l,int r,int p=1){ if(tree[p].l\u003e=l\u0026\u0026tree[p].r\u003c=r)return tree[p].sum; int mid=(tree[p].l+tree[p].r)\u003e\u003e1; ll sum=0; if(l\u003c=mid)sum+=query(l,r,p\u003c\u003c1); if(r\u003emid)sum+=query(l,r,p\u003c\u003c1|1); return sum; } inline void solve(){ cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++)cin\u003e\u003ea[i]; build(1,n); int opt; int u,v,w; while(m--){ cin\u003e\u003eopt; if(opt==1){ cin\u003e\u003eu\u003e\u003ev; cout\u003c\u003cquery(u,v)\u003c\u003cendl; }else if(opt==2){ cin\u003e\u003eu\u003e\u003ev\u003e\u003ew; if(w\u003c=tree[1].mx)Mod(u,v,w); }else{ cin\u003e\u003eu\u003e\u003ev; Set(u,v); } } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-21","objectID":"/posts/cf438d/:0:3","tags":["codeforces","segment tree"],"title":"Codeforces 438D The Child and Sequence","uri":"/posts/cf438d/"},{"categories":["2021/10"],"content":"小结 势能线段树的简单应用 ","date":"2021-10-21","objectID":"/posts/cf438d/:0:4","tags":["codeforces","segment tree"],"title":"Codeforces 438D The Child and Sequence","uri":"/posts/cf438d/"},{"categories":["2021/10"],"content":"传送门 ","date":"2021-10-13","objectID":"/posts/cf1042d/:0:0","tags":["codeforces","segment tree"],"title":"Codeforces 1042D Petya and Array","uri":"/posts/cf1042d/"},{"categories":["2021/10"],"content":"题意 输出一个数组中有多少连续的子序列之和小于$m$ ","date":"2021-10-13","objectID":"/posts/cf1042d/:0:1","tags":["codeforces","segment tree"],"title":"Codeforces 1042D Petya and Array","uri":"/posts/cf1042d/"},{"categories":["2021/10"],"content":"思路 先计算出前缀和，显然我们需要找出满足$sum_r-sum_l\u003ct$的两个下标，可以转化为$sum_r-t\u003csum_l$ 然后建立前缀和的权值线段树，并在修改前查询对于当前点$r$，有多少大于$sum_r+t$的点，求和即可 另外此题需要离散化 ","date":"2021-10-13","objectID":"/posts/cf1042d/:0:2","tags":["codeforces","segment tree"],"title":"Codeforces 1042D Petya and Array","uri":"/posts/cf1042d/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; typedef long long ll; const int maxn=4e5+5; ll n,m; ll a[maxn],num[maxn]; struct node{ int l,r; ll val; }tree[maxn\u003c\u003c2]; vector\u003cll\u003e v; inline int getid(ll x){ return lower_bound(v.begin(),v.end(),x)-v.begin()+1;}; void discrete(){ sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end()); } void build(int l,int r,int o=1){ tree[o].l=l,tree[o].r=r; tree[o].val=0; if(tree[o].l==tree[o].r)return ; int mid=(tree[o].l+tree[o].r)\u003e\u003e1; build(l,mid,o\u003c\u003c1); build(mid+1,r,o\u003c\u003c1|1); } void pushup(int o){ tree[o].val=tree[o\u003c\u003c1].val+tree[o\u003c\u003c1|1].val; } void change(int lr,int o=1){ if(tree[o].l==tree[o].r){ tree[o].val++; return ; } int mid=(tree[o].l+tree[o].r)\u003e\u003e1; if(lr\u003c=mid)change(lr,o\u003c\u003c1); else change(lr,o\u003c\u003c1|1); pushup(o); } ll query(int l,int r,int o=1){ if(l\u003c=tree[o].l\u0026\u0026r\u003e=tree[o].r)return tree[o].val; int mid=(tree[o].l+tree[o].r)\u003e\u003e1; ll sum=0; if(l\u003c=mid)sum+=query(l,r,o\u003c\u003c1); if(r\u003emid)sum+=query(l,r,o\u003c\u003c1|1); return sum; } inline void solve(){ cin\u003e\u003en\u003e\u003em; v.push_back(0); for(int i=1;i\u003c=n;i++){ cin\u003e\u003ea[i]; a[i]+=a[i-1]; v.push_back(a[i]); } for(int i=1;i\u003c=n;i++)v.push_back(a[i]-m+1); discrete(); for(int i=1;i\u003c=n;i++)num[i]=getid(a[i]); build(1,v.size()); change(getid(0)); ll ans=0; for(int i=1;i\u003c=n;i++){ int tmp=query(getid(a[i]-m+1),v.size()); ans+=tmp; change(num[i]); } cout\u003c\u003cans\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-13","objectID":"/posts/cf1042d/:0:3","tags":["codeforces","segment tree"],"title":"Codeforces 1042D Petya and Array","uri":"/posts/cf1042d/"},{"categories":["2021/10"],"content":"小结 权值线段树和前缀和的简单应用，码量有点大，细节出错找bug还是找了很久 ","date":"2021-10-13","objectID":"/posts/cf1042d/:0:4","tags":["codeforces","segment tree"],"title":"Codeforces 1042D Petya and Array","uri":"/posts/cf1042d/"},{"categories":["2021/10"],"content":"传送门 step1 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:0:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"A. Suffix Array - 1 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:1:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 求后缀数组 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:1:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 直接上板子 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:1:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=1e5+5; const int maxm=1e9; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i],tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } char tmp[maxn]; inline void solve(){ cin\u003e\u003e(tmp+1); n=strlen(tmp+1); for(int i=1;i\u003c=n;i++)s[i]=tmp[i]; s[n+1]='$'; SuffixArray(); for(int i=1;i\u003c=N;i++)cout\u003c\u003csa[i]-1\u003c\u003c\" \"; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } step2 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:1:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"A. Suffix Array - 2 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:2:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 更快的求后缀数组 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:2:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 同样直接上板子 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:2:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=1e5+5; const int maxm=1e9; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i],tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } char tmp[maxn]; inline void solve(){ cin\u003e\u003e(tmp+1); n=strlen(tmp+1); for(int i=1;i\u003c=n;i++)s[i]=tmp[i]; s[n+1]='$'; SuffixArray(); for(int i=1;i\u003c=N;i++)cout\u003c\u003csa[i]-1\u003c\u003c\" \"; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } step3 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:2:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"A. Substring Search ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:3:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 给定字符串$t$，$n$次询问，给定字符串$s_i$是否为$t$的子串 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:3:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 得出后缀数组之后，在后缀数组中二分查找即可 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:3:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=3e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i],tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } char tmp[maxn]; int len; bool check(int x){ x=sa[x]; for(int i=0;i\u003cmin(len,N-x+1);i++){ if(s[x+i]\u003etmp[i+1])return 1; else if(s[x+i]\u003ctmp[i+1])return 0; } return len\u003c=N-x+1; } int bsearch_1(int l,int r){ len=strlen(tmp+1); while(l\u003cr){ int mid=(l+r)\u003e\u003e1; if(check(mid))r=mid; else l=mid+1; } l=sa[l]; if(len\u003eN-l+1)return 0; for(int i=0;i\u003cmin(len,N-l+1);i++){ if(s[l+i]!=tmp[i+1]){ return 0; } } return 1; } inline void solve(){ cin\u003e\u003e(s+1)\u003e\u003en; SuffixArray(); for(int i=1;i\u003c=n;i++){ cin\u003e\u003e(tmp+1); if(bsearch_1(1,N))cout\u003c\u003c\"Yes\"\u003c\u003cendl; else cout\u003c\u003c\"No\"\u003c\u003cendl; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:3:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"B. Counting Substrings ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:4:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 给定字符串$t$，$n$次询问，给定字符串$s_i$在$t$中出现的次数 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:4:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 二分查找找出第一个字典序比$s_i$小的和第一个比$s_i$大的即可 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:4:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=3e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i],tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } char tmp[maxn]; int len; bool check1(int x){ string a(tmp+1),b; x=sa[x]; for(int i=0;i\u003cmin(N-x+1,len);i++)b.push_back(s[x+i]); return b\u003e=a; } int bsearch_1(int l,int r){ while(l\u003cr){ int mid=(l+r)\u003e\u003e1; if(check1(mid))r=mid; else l=mid+1; } return l; } bool check2(int x){ string a(tmp+1),b; x=sa[x]; for(int i=0;i\u003cmin(N-x+1,len);i++)b.push_back(s[x+i]); return b\u003ea; } int bsearch_2(int l,int r){ while(l\u003cr){ int mid=(l+r+1)\u003e\u003e1; if(check2(mid))r=mid-1; else l=mid; } return l; } inline void solve(){ cin\u003e\u003e(s+1)\u003e\u003en; SuffixArray(); for(int i=1;i\u003c=n;i++){ cin\u003e\u003e(tmp+1); len=strlen(tmp+1); int ans1=bsearch_2(1,N),ans2=bsearch_1(1,N); string a(tmp+1),b; for(int i=0;i\u003cmin(N-sa[ans2]+1,len);i++)b.push_back(s[sa[ans2]+i]); if(a!=b)cout\u003c\u003c0\u003c\u003cendl; else cout\u003c\u003cans1-ans2+1\u003c\u003cendl; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } step4 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:4:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"A. Suffix Array and LCP ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:5:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 求后缀数组以及$height$数组 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:5:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 直接上板子 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:5:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=3e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } inline void solve(){ string str; cin\u003e\u003estr; str.push_back('$'); for(int i=0;i\u003cstr.size();i++)s[i+1]=str[i]; SuffixArray(); for(int i=1;i\u003c=N;i++)cout\u003c\u003csa[i]-1\u003c\u003c\" \"; cout\u003c\u003cendl; Height(); for(int i=2;i\u003c=N;i++)cout\u003c\u003cht[i]\u003c\u003c\" \"; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } step5 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:5:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"A. Number of Different Substrings ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:6:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 对于给定字符串$s$，求出其不同子串的数量 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:6:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 对于后缀$sa[i]$和后缀$sa[i+1]$，后缀$sa[i+1]$的贡献为其长度减去与后缀$sa[i]$部分，所以不同子串的数量为$n(n-1)/2-\\sum_{i=1}^n height[i]$ ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:6:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; typedef long long ll; const int maxn=4e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=75; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]-'0'+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } inline void solve(){ cin\u003e\u003e(s+1); SuffixArray(); Height(); ll ans=0; for(int i=1;i\u003c=N;i++)ans+=(ll)sa[i]-ht[i]; cout\u003c\u003cans\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:6:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"B. Longest Common Substring ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:7:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 给定字符串$s$和$t$，输出其最长公共子串 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:7:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 首先将两个字符串拼接在一起用$分隔 很容易想到两个字符串中以最长公共子串味首的后缀在后缀数组中必然相邻，所以在$height$数组中找出两个后缀来自不同的字符串且值最大的位置即可 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:7:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=4e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } inline void solve(){ string s1,s2; cin\u003e\u003es1\u003e\u003es2; int len1=s1.size(),len2=s2.size(); s1+='$'; s1+=s2; for(int i=0;i\u003cs1.size();i++)s[i+1]=s1[i]; SuffixArray(); Height(); int ans=1; for(int i=2;i\u003c=N;i++){ if(sa[i]\u003c=len1\u0026\u0026sa[i-1]\u003elen1+1\u0026\u0026ht[ans]\u003cht[i])ans=i; if(sa[i-1]\u003c=len1\u0026\u0026sa[i]\u003elen1+1\u0026\u0026ht[ans]\u003cht[i])ans=i; } for(int i=0;i\u003cht[ans];i++)cout\u003c\u003cs[sa[ans]+i]; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:7:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"C. Sorting Substrings ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:8:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 给定字符串$s$以及其$n$个子串，将其排序后输出（子串均以$l,r$的方式给出以及输出） ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:8:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 对于子串$[l_i,r_i]$和$[l_j,r_j]$，当$lcp(l_i,l_j) \\geqslant min(r_i-l_i+1,r_j-l_j+1)$，则只需要比较其长度即可，否则则比较$rank[l_i]$和$rank[l_j]$ ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:8:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define x first #define y second typedef pair\u003cint,int\u003e P; const int maxn=4e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } int st[maxn][30],plg[maxn]; void ST_pre(){ plg[1]=0; for(int i=2;i\u003c=N;i++)plg[i]=plg[i/2]+1; for(int i=1;i\u003c=N;i++)st[i][0]=ht[i]; for(int j=1;j\u003c=plg[N];j++){ for(int i=1;i\u003c=N-(1\u003c\u003cj)+1;i++){ st[i][j]=min(st[i][j-1],st[i+(1\u003c\u003c(j-1))][j-1]); } } } int ST_query(int l,int r){ int k=plg[r-l+1]; return min(st[l][k],st[r-(1\u003c\u003ck)+1][k]); } int lcp(int a,int b){//第a个后缀与第b个后缀的最长公共前缀 a=rk[a],b=rk[b]; if(a\u003eb)swap(a,b); return ST_query(a+1,b); } vector\u003cP\u003e v; bool f(P a,P b){ int lena=a.y-a.x+1; int lenb=b.y-b.x+1; int len=lcp(a.x,b.x); if(a.x==b.x)len=inf; if(len\u003e=min(lena,lenb)){ if(lena\u003clenb)return 1; else if(lena\u003elenb)return 0; else if(a.x\u003cb.x)return 1; else if(a.x\u003eb.x)return 0; else return a.y\u003cb.y; } return rk[a.x]\u003crk[b.x]; } inline void solve(){ cin\u003e\u003e(s+1); SuffixArray(); Height(); ST_pre(); cin\u003e\u003en; int a,b; for(int i=0;i\u003cn;i++){ cin\u003e\u003ea\u003e\u003eb; v.push_back(P(a,b)); } sort(v.begin(),v.end(),f); for(int i=0;i\u003cn;i++)cout\u003c\u003cv[i].x\u003c\u003c\" \"\u003c\u003cv[i].y\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:8:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"D. Borders ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:9:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 如果一个字符串同时是另一个字符串的前缀和后缀，则称这个字符串为另一个字符串的$border$ 对于给定串$s$，输出其所有子串的$border$数量之和 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:9:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 对于后缀$i$和后缀$j$这对后缀的贡献为$lcp(i,j)$，因此答案为$\\sum_{i=1}^n \\sum_{j=i}^nlcp(i,j)$ 而$lcp(i,j)$本质为$min{height[i+1…j]}$ 因此问题变成了求height数组的子数组最小值之和，用单调栈和dp优化这个过程 构造递增的单调栈，定义$sum[i]$为以$i$为右端点的区间最小值之和，对于$i$我们找到第一个比$i$小的位置$j$，$sum[i]$由两部分构成，左端点在$j$的右侧的子数组之和为$(i-j)*height[i]$，而左端点在$j$的左侧的子数组之和为$sum[j]$，所以$sum[i]=(i-j)*height[i]+sum[j]$ ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:9:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; typedef long long ll; const int maxn=4e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } stack\u003cint\u003e st; ll sum[maxn]; inline void solve(){ cin\u003e\u003e(s+1); SuffixArray(); Height(); ll ans=0; for(int i=1;i\u003c=N;i++)ans+=i; for(ll i=2;i\u003c=N;i++){ while(!st.empty()\u0026\u0026ht[st.top()]\u003e=ht[i])st.pop(); sum[i]=st.empty()?(i-1)*ht[i]:(i-st.top())*ht[i]+sum[st.top()]; st.push(i); } for(int i=2;i\u003c=N;i++)ans+=sum[i]; cout\u003c\u003cans\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:9:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"E. Refrain ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:10:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 对给定字符串$s$，找到子串$t$，$t$满足出现次数与字符串长度的乘积在所有子串中最大 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:10:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 对于任意子串为首的后缀其在后缀数组中出现都是连续的，该问题可以化简为在$height$数组中求最大矩形 利用单调栈找出对于任意$height[i]$左侧和右侧第一个比$height[i]$小的位置记为$pre[i]$和$nxt[i]$，$height[i]*(nxt[i]-pre[i])$即为以$height[i]$为高宽度最宽的矩形，求出最值即可 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:10:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; typedef long long ll; const int maxn=4e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=300; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } stack\u003cint\u003e st; ll pre[maxn],nxt[maxn]; inline void solve(){ cin\u003e\u003en\u003e\u003em; int c; string ss; for(int i=1;i\u003c=n;i++){ cin\u003e\u003ec; s[i]='a'+c; } SuffixArray(); Height(); ll ans=N; for(int i=2;i\u003c=N;i++){ while(st.size()\u0026\u0026ht[i]\u003c=ht[st.top()])st.pop(); pre[i]=st.size()?st.top():1; st.push(i); } while(st.size())st.pop(); for(int i=N;i\u003e=2;i--){ while(st.size()\u0026\u0026ht[i]\u003c=ht[st.top()])st.pop(); nxt[i]=st.size()?st.top():N+1; st.push(i); } int len=0,id=0; for(int i=2;i\u003c=N;i++){ if((nxt[i]-pre[i])*ht[i]\u003eans||((nxt[i]-pre[i])*ht[i]==ans\u0026\u0026(nxt[i]-pre[i])\u003clen)){ ans=(nxt[i]-pre[i])*ht[i]; len=nxt[i]-pre[i]; id=i; } } if(ans==N){ cout\u003c\u003cN\u003c\u003cendl; cout\u003c\u003cN\u003c\u003cendl; for(int i=1;i\u003c=N;i++)cout\u003c\u003cs[i]-'a'\u003c\u003c\" \"; return ; } cout\u003c\u003cans\u003c\u003cendl; cout\u003c\u003cans/len\u003c\u003cendl; for(int i=0;i\u003cans/len;i++)cout\u003c\u003cs[sa[id]+i]-'a'\u003c\u003c\" \"; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:10:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"F. Periodic Substring ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:11:0","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"题意 求出重复次数最多的连续子串 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:11:1","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"思路 枚举子串长度为$i$，如果子串中循环节重复次数不少于两次，那么字符$s[0],s[i],s[2i],s[3i]…$必然会有两个或两个以上出现在该子串中，不妨设前两个字符为$s[j],s[j+i]$，我们记$lcp(j,j+i)$为$cnt$我们考虑两种情况 如果$s[j]$是子串的首字符，那么该子串的循环节重复次数为$cnt/i$，此时子串为$s[j…j+i+cnt-cnt%i]$ 否则，$s[j]$左侧的$i-cnt%i$个字符有可能可以继续拼凑出一个循环节，我们记此时的起点$j-(i-cnt%i)$为$k$，当$lcp(k,k+i) \\geqslant i$则可以拼凑，此时子串为$s[k…j+i+cnt]$ ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:11:2","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/10"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=4e5+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=75; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]-'0'+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } int st[maxn][30],plg[maxn]; void ST_pre(){ plg[1]=0; for(int i=2;i\u003c=N;i++)plg[i]=plg[i/2]+1; for(int i=1;i\u003c=N;i++)st[i][0]=ht[i]; for(int j=1;j\u003c=plg[N];j++){ for(int i=1;i\u003c=N-(1\u003c\u003cj)+1;i++){ st[i][j]=min(st[i][j-1],st[i+(1\u003c\u003c(j-1))][j-1]); } } } int ST_query(int l,int r){ int k=plg[r-l+1]; return min(st[l][k],st[r-(1\u003c\u003ck)+1][k]); } int lcp(int a,int b){//第a个后缀与第b个后缀的最长公共前缀 a=rk[a],b=rk[b]; if(a\u003eb)swap(a,b); return ST_query(a+1,b); } inline void solve(){ cin\u003e\u003e(s+1); SuffixArray(); Height(); ST_pre(); int ans=1; for(int i=1;i\u003c=N;i++){ for(int j=1;j+i\u003c=N;j+=i){ int cnt=lcp(j,j+i); int k=j-(i-cnt%i); cnt=cnt/i+1; if(k\u003e=1\u0026\u0026lcp(k,k+i)\u003e=i)cnt++; ans=max(cnt,ans); } } cout\u003c\u003cans\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } 小结 通过这么多题算是对后缀数组有了一个初步的了解，感叹一下还是自己会的东西太少了，在做与单调栈结合的题目费了很大的功夫 后缀数组的学习到这里算是告一段落了 ","date":"2021-10-02","objectID":"/posts/edusuffixarray/:11:3","tags":["codeforces","EDU","suffix array"],"title":"Codeforces Edu SuffixArray","uri":"/posts/edusuffixarray/"},{"categories":["2021/8"],"content":"传送门 ","date":"2021-08-28","objectID":"/posts/cf126b/:0:0","tags":["codeforces","KMP"],"title":"Codeforces 126B Password","uri":"/posts/cf126b/"},{"categories":["2021/8"],"content":"题意 给一个字符串$S$，找到最长的字符串$T$同时为$S$的前缀、后缀且作为非前后缀出现在字符串中 ","date":"2021-08-28","objectID":"/posts/cf126b/:0:1","tags":["codeforces","KMP"],"title":"Codeforces 126B Password","uri":"/posts/cf126b/"},{"categories":["2021/8"],"content":"思路 利用next数组求出串$S$所有相同的前后缀，然后遍历next数组查找出现的最长的且与上一步求得的相同的前后缀的相同子串即可 ","date":"2021-08-28","objectID":"/posts/cf126b/:0:2","tags":["codeforces","KMP"],"title":"Codeforces 126B Password","uri":"/posts/cf126b/"},{"categories":["2021/8"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' const int maxn=1e6+5; string s; int nxt[maxn]; void kmp_pre(string s,int* nxt){ int i,j; j=nxt[0]=-1; i=0; while(i\u003cs.size()){ while(j!=-1\u0026\u0026s[i]!=s[j])j=nxt[j]; nxt[++i]=++j; } } inline void solve(){ cin\u003e\u003es; kmp_pre(s,nxt); map\u003cint,int\u003e mp; int t=nxt[s.size()]; while(t!=-1){ mp[t]=1; t=nxt[t]; } int ans=0; for(int i=2;i\u003cs.size();i++){ if(mp[nxt[i]])ans=max(ans,nxt[i]); } if(ans){ for(int i=0;i\u003cans;i++)cout\u003c\u003cs[i]; cout\u003c\u003cendl; }else cout\u003c\u003c\"Just a legend\"\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; while(__--){ solve(); } return 0; } ","date":"2021-08-28","objectID":"/posts/cf126b/:0:3","tags":["codeforces","KMP"],"title":"Codeforces 126B Password","uri":"/posts/cf126b/"},{"categories":["2021/8"],"content":"小结 搁置了很久的一道题，对next数组的简单应用，今天看了一下直接秒掉了 ","date":"2021-08-28","objectID":"/posts/cf126b/:0:4","tags":["codeforces","KMP"],"title":"Codeforces 126B Password","uri":"/posts/cf126b/"},{"categories":["2021/8"],"content":"传送门 ","date":"2021-08-28","objectID":"/posts/cf1562e/:0:0","tags":["codeforces","suffix array","sparse table"],"title":"Codeforces 1562E Rescue Niwen!","uri":"/posts/cf1562e/"},{"categories":["2021/8"],"content":"题意 将一个字符串按如下形式拆分为若干个串： 以$abcd$为例，拆分为$a,ab,abc,abcd,b,bc,bcd,c,cd,d$ 输出最长的字典序严格上升的子序列（可以不连续）的长度 ","date":"2021-08-28","objectID":"/posts/cf1562e/:0:1","tags":["codeforces","suffix array","sparse table"],"title":"Codeforces 1562E Rescue Niwen!","uri":"/posts/cf1562e/"},{"categories":["2021/8"],"content":"思路 将所有串按原串后缀分组 对于任意后缀$i$，其最大贡献为$n-i+1$，当且仅当后缀$j\u003ei$且$rk[j]\u003erk[i]$时，后缀$j$可置于后缀$i$之后，且贡献度为$n-i+1-lcp(i,j)$ ","date":"2021-08-28","objectID":"/posts/cf1562e/:0:2","tags":["codeforces","suffix array","sparse table"],"title":"Codeforces 1562E Rescue Niwen!","uri":"/posts/cf1562e/"},{"categories":["2021/8"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int maxn=5e3+5; int n,m; int N,M,rk[maxn],sa[maxn],tp[maxn],tax[maxn],px[maxn],ht[maxn]; char s[maxn]; ll ans[maxn]; void ssort(){ for(int i=0;i\u003c=M;i++)tax[i]=0; for(int i=1;i\u003c=N;i++)tax[px[i]=rk[tp[i]]]++; for(int i=1;i\u003c=M;i++)tax[i]+=tax[i-1]; for(int i=N;i\u003e0;i--)sa[tax[px[i]]--]=tp[i]; } inline bool cmp(int x,int y,int w){ return tp[x]==tp[y]\u0026\u0026tp[x+w]==tp[y+w]; } void SuffixArray(){ M=75; N=strlen(s+1); memset(rk,0,sizeof rk); for(int i=1;i\u003c=N;i++)rk[i]=s[i]-'0'+1,tp[i]=i; ssort(); for(int w=1,p=0;p\u003cN;M=p,w\u003c\u003c=1){ p=0; for(int i=1;i\u003c=w;i++)tp[++p]=N-w+i; for(int i=1;i\u003c=N;i++)if(sa[i]\u003ew)tp[++p]=sa[i]-w; ssort(); memcpy(tp,rk,sizeof rk); rk[sa[1]]=p=1; for(int i=2;i\u003c=N;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } } void Height(){ int j,k=0; for(int i=1;i\u003c=N;i++){ if(k)k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k])k++; ht[rk[i]]=k; } } int st[maxn][30],plg[maxn]; void ST_pre(){ plg[1]=0; for(int i=2;i\u003c=n;i++)plg[i]=plg[i/2]+1; for(int i=1;i\u003c=n;i++)st[i][0]=ht[i]; for(int j=1;j\u003c=plg[n];j++){ for(int i=1;i\u003c=n-(1\u003c\u003cj)+1;i++){ st[i][j]=min(st[i][j-1],st[i+(1\u003c\u003c(j-1))][j-1]); } } } int ST_query(int l,int r){ int k=plg[r-l+1]; return min(st[l][k],st[r-(1\u003c\u003ck)+1][k]); } int lcp(int a,int b){//排名第a的后缀与排名第b的后缀的最长公共前缀 if(a\u003eb)swap(a,b); return ST_query(a+1,b); } inline void solve(){ cin\u003e\u003en\u003e\u003e(s+1); SuffixArray(); Height(); ST_pre(); ll res=0; for(int i=1;i\u003c=n;i++){ int x=sa[i]; ans[x]=n-x+1; for(int j=1;j\u003ci;j++){ if(sa[j]\u003cx)ans[x]=max(ans[x],ans[sa[j]]+n-x+1-lcp(j,i)); } res=max(res,ans[x]); } cout\u003c\u003cres\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-08-28","objectID":"/posts/cf1562e/:0:3","tags":["codeforces","suffix array","sparse table"],"title":"Codeforces 1562E Rescue Niwen!","uri":"/posts/cf1562e/"},{"categories":["2021/8"],"content":"小结 最近一直在学的后缀数组居然现场遇到了没做出来，真是离紫名最近的一回 😭 ","date":"2021-08-28","objectID":"/posts/cf1562e/:0:4","tags":["codeforces","suffix array","sparse table"],"title":"Codeforces 1562E Rescue Niwen!","uri":"/posts/cf1562e/"},{"categories":["2021/8"],"content":"传送门 ","date":"2021-08-25","objectID":"/posts/poj3463/:0:0","tags":["poj","dijkstra"],"title":"POJ 3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"题意 给一张图，求到终点最短路个数以及与最短路相差为1的次短路的个数之和 ","date":"2021-08-25","objectID":"/posts/poj3463/:0:1","tags":["poj","dijkstra"],"title":"POJ 3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"思路 最短路计数和次短路计数的模板题，将次短路丢入优先队列中即可。 ","date":"2021-08-25","objectID":"/posts/poj3463/:0:2","tags":["poj","dijkstra"],"title":"POJ 3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"代码 /** * Author: ShacozzZ * Created: 2021-08-25 21:23:21 **/ #include\u003calgorithm\u003e#include\u003ciostream\u003e#include\u003cmap\u003e#include\u003cqueue\u003e#include\u003cvector\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef long long ll; typedef pair\u003cint,int\u003e P; const int inf=0x3f3f3f3f; const int maxn=1e5+5; int n,m; struct edge{ int v,w; edge(){} edge(int vv,int ww){v=vv;w=ww;} }; struct node{ int x,y,z; node(){} node(int xx,int yy,int zz){x=xx;y=yy;z=zz;} bool operator\u003e(const node \u0026b)const{return x\u003eb.x;} }; vector\u003cedge\u003e g[maxn]; int st,en,dis1[maxn],dis2[maxn],cnt1[maxn],cnt2[maxn]; void init(){ for(int i=0;i\u003c=n;i++){ g[i].clear(); dis1[i]=dis2[i]=inf; cnt1[i]=cnt2[i]=0; } } void dij(){ priority_queue\u003cnode,vector\u003cnode\u003e,greater\u003cnode\u003e\u003e q; dis1[st]=0; cnt1[st]=1; q.push(node(0,st,1)); while(!q.empty()){ node p=q.top(); q.pop(); int u=p.y; int d=p.x; int num=(p.z==1?cnt1[u]:cnt2[u]); if(p.z==1\u0026\u0026dis1[u]\u003cp.x)continue; if(p.z==2\u0026\u0026dis2[u]\u003cp.x)continue; for(int i=0;i\u003cg[u].size();i++){ int v=g[u][i].v,w=g[u][i].w; if(d+w\u003cdis1[v]){ dis2[v]=dis1[v]; cnt2[v]=cnt1[v]; q.push(node(dis2[v],v,2)); dis1[v]=d+w; cnt1[v]=num; q.push(node(dis1[v],v,1)); }else if(d+w==dis1[v])cnt1[v]+=num; else if(d+w\u003cdis2[v]){ dis2[v]=d+w; cnt2[v]=num; q.push(node(dis2[v],v,2)); }else if(d+w==dis2[v])cnt2[v]+=num; } } } inline void solve(){ cin\u003e\u003en\u003e\u003em; int u,v,w; init(); for(int i=0;i\u003cm;i++){ cin\u003e\u003eu\u003e\u003ev\u003e\u003ew; g[u].push_back(edge(v,w)); } cin\u003e\u003est\u003e\u003een; dij(); cout\u003c\u003c(dis2[en]-dis1[en]==1?cnt1[en]+cnt2[en]:cnt1[en])\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-08-25","objectID":"/posts/poj3463/:0:3","tags":["poj","dijkstra"],"title":"POJ 3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"小结 对最短路的理解又加深了（好耶 ","date":"2021-08-25","objectID":"/posts/poj3463/:0:4","tags":["poj","dijkstra"],"title":"POJ 3463 Sightseeing","uri":"/posts/poj3463/"},{"categories":["2021/8"],"content":"传送门 ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:0","tags":["gym","dp","tree"],"title":"2021CCPC东北四省赛 C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"题意 问有多少种删点方案使得剩下的点至少与一个点相连 ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:1","tags":["gym","dp","tree"],"title":"2021CCPC东北四省赛 C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"思路 定义$dp[i][0/1/2]$代表对于节点i为根的子树，将节点$i$删去、保留节点$i$且节点$i$只与父节点相连、保留节点$i$且与子节点相连的方案数 对于第三种情况，通过先算得保留节点i的所有方案数减去不合法的方案数，即减去第二种情况的方案数 状态转移方程如下： $dp[u][0]=\\prod_{v\\in son_{u}}(dp[v][0]+dp[v][2])$ $dp[u][1]=\\prod_{v\\in son_{u}}dp[v][0]$ $dp[u][2]=\\prod_{v\\in son_{u}}(dp[v][0]+dp[v][1]+dp[v][2])-dp[u][1]$ ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:2","tags":["gym","dp","tree"],"title":"2021CCPC东北四省赛 C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int md=998244353; const int maxn=2e5+5; int n,m; ll dp[maxn][3]; vector\u003cint\u003e g[maxn]; void dfs(int u,int fa){ for(int v:g[u]){ if(v==fa)continue; dfs(v,u); dp[u][0]=dp[u][0]*(dp[v][0]+dp[v][2])%md;; dp[u][1]=dp[u][1]*dp[v][0]%md; dp[u][2]=dp[u][2]*(dp[v][0]+dp[v][1]+dp[v][2])%md; } dp[u][2]-=dp[u][1]; if(dp[u][2])dp[u][2]+=md; } inline void solve(){ cin\u003e\u003en; for(int i=1;i\u003c=n;i++)dp[i][0]=dp[i][1]=dp[i][2]=1,g[i].clear(); int u,v; for(int i=1;i\u003cn;i++){ cin\u003e\u003eu\u003e\u003ev; g[u].push_back(v); g[v].push_back(u); } dfs(1,0); cout\u003c\u003c(dp[1][0]+dp[1][2])%md\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:3","tags":["gym","dp","tree"],"title":"2021CCPC东北四省赛 C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/8"],"content":"小结 训练赛补题，离谱的事在训练赛时手动模拟都没有数出样例中的22种方案（笑） ","date":"2021-08-12","objectID":"/posts/gym103145c/:0:4","tags":["gym","dp","tree"],"title":"2021CCPC东北四省赛 C Vertex Deletion","uri":"/posts/gym103145c/"},{"categories":["2021/7"],"content":"传送门 ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:0","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces 1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"题意 给一个数组，分割成三个区间，使得左区间的最大值等于中间区间的最小值等于右区间的最大值 ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:1","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces 1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"思路 首先用线段树维护区间的最大值最小值不难想到，然后遍历数组，再确定一个断点的条件（即确定了左区间）下，发现另外一个断点所确定的两个区间的最大值和最小值都是具有单调性的，即：中间区间越大则最小值越小且右区间最大值越小 时间复杂度$O(nlognlogn)$ ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:2","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces 1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int inf=0x3f3f3f3f; const int maxn=2e5+5; int n,m,a[maxn]; ll num[maxn]; struct seq_node{ int l,r; ll mn,mx; }tree[maxn\u003c\u003c2]; inline void pushup(int o){ tree[o].mn=min(tree[o\u003c\u003c1].mn,tree[o\u003c\u003c1|1].mn); tree[o].mx=max(tree[o\u003c\u003c1].mx,tree[o\u003c\u003c1|1].mx); } void build_tree(int l,int r,int o){ tree[o].l=l,tree[o].r=r; if(l==r){ tree[o].mx=tree[o].mn=num[l]; return ; } int mid=(l+r)\u003e\u003e1; build_tree(l,mid,o\u003c\u003c1); build_tree(mid+1,r,o\u003c\u003c1|1); pushup(o); } int query_mx(int l,int r,int o){ if(tree[o].l\u003e=l\u0026\u0026tree[o].r\u003c=r)return tree[o].mx; int mid=(tree[o].l+tree[o].r)\u003e\u003e1; int mx=0; if(l\u003c=mid)mx=max(mx,query_mx(l,r,o\u003c\u003c1)); if(r\u003emid)mx=max(mx,query_mx(l,r,o\u003c\u003c1|1)); return mx; } int query_mn(int l,int r,int o){ if(tree[o].l\u003e=l\u0026\u0026tree[o].r\u003c=r)return tree[o].mn; int mid=(tree[o].l+tree[o].r)\u003e\u003e1; int mn=inf; if(l\u003c=mid)mn=min(mn,query_mn(l,r,o\u003c\u003c1)); if(r\u003emid)mn=min(mn,query_mn(l,r,o\u003c\u003c1|1)); return mn; } inline void solve(){ cin\u003e\u003en; for(int i=1;i\u003c=n;i++)cin\u003e\u003enum[i]; build_tree(1,n,1); for(int i=1;i\u003cn-1;i++){ int l=i+1,r=n-1; int mx1=query_mx(1,i,1),mn,mx2; while(l\u003c=r){ int mid=(l+r)\u003e\u003e1; // ck(mid) mn=query_mn(i+1,mid,1); mx2=query_mx(mid+1,n,1); if(mn\u003emx1||mx2\u003emx1)l=mid+1; else if(mn\u003cmx1||mx2\u003cmx1)r=mid-1; else{ cout\u003c\u003c\"YES\"\u003c\u003cendl; cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cmid-i\u003c\u003c\" \"\u003c\u003cn-mid\u003c\u003cendl; return ; } } } cout\u003c\u003c\"NO\"\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:3","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces 1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"小结 大概是稍微复习了一下线段树，二分的思路很巧妙，也是通过看了别人的题解才想到的 ","date":"2021-07-27","objectID":"/posts/cf1454f/:0:4","tags":["codeforces","segment tree"," binary search"],"title":"Codeforces 1454F Array Partition","uri":"/posts/cf1454f/"},{"categories":["2021/7"],"content":"传送门 ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:0","tags":["codeforces","dfs"],"title":"Codeforces 1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"题意 给$n$个点$n$条边的无向图，求有多少条简单路径 ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:1","tags":["codeforces","dfs"],"title":"Codeforces 1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"思路 不难发现图为一棵树增加一条边使得树中出现了一个环，首先找出环，然后如果两个点之间经过环，则有两条简单路径，否则为一条 通过两次dfs，第一次找出有哪些点在环上，第二次计算答案 ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:2","tags":["codeforces","dfs"],"title":"Codeforces 1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' typedef long long ll; const int maxn=2e5+5; const int maxm=1e9; ll n,m,ans; vector\u003cint\u003e g[maxn]; set\u003cint\u003e c; bool vis[maxn]; int fa[maxn]; bool ok=0; void init(){} void dfs1(int u){ vis[u]=1; for(int i=0;i\u003cg[u].size();i++){ if(ok)return ; int v=g[u][i]; if(v!=fa[u]){ if(vis[v]){ while(u!=v){ c.insert(u); u=fa[u]; } c.insert(v); ok=1; }else{ fa[v]=u; dfs1(v); } } } } ll dfs2(int u){ ll res=1; vis[u]=1; for(int i=0;i\u003cg[u].size();i++){ int v=g[u][i]; if(!vis[v]\u0026\u0026(!c.count(u)||!c.count(v))){ res+=dfs2(v); } } return res; } inline void solve(){ cin\u003e\u003en; for(int i=0;i\u003c=n;i++){ g[i].clear(); vis[i]=0; } c.clear(); ans=ok=0; for(int i=1;i\u003c=n;i++){ int u,v; cin\u003e\u003eu\u003e\u003ev; g[u].push_back(v); g[v].push_back(u); } dfs1(1); for(int i=0;i\u003c=n;i++)vis[i]=0; for(int i=1;i\u003c=n;i++){ if(!vis[i]){ ll res=dfs2(i); ans+=res*(res-1)/2+res*(n-res); } } cout\u003c\u003cans\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:3","tags":["codeforces","dfs"],"title":"Codeforces 1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"小结 很简单的一个题，零零碎碎的bug找了太久了 ","date":"2021-07-26","objectID":"/posts/cf1454e/:0:4","tags":["codeforces","dfs"],"title":"Codeforces 1454E Number of Simple Paths","uri":"/posts/cf1454e/"},{"categories":["2021/7"],"content":"传送门 ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:0","tags":["codeforces","topological sorting"],"title":"Codeforces 1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"题意 给一个图包含有向边和无向边，将所有无向边改为有向边并且使图中不存在环 ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:1","tags":["codeforces","topological sorting"],"title":"Codeforces 1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"思路 首先删除掉所有无向边，通过拓扑排序判断是否有环，如果不存在环，则将无向边改为由拓扑序小的点指向拓扑序大的点的有向边 ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:2","tags":["codeforces","topological sorting"],"title":"Codeforces 1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef pair\u003cint,int\u003e Pii; const int maxn=2e5+5; int n,m,rk[maxn]; vector\u003cPii\u003e e; void init(){} vector\u003cint\u003e g[maxn]; vector\u003cint\u003e topo; int vis[maxn]; bool dfs(int u){ vis[u]=-1; for(auto v:g[u]){ if(vis[v]\u003c0)return 0; else if(!vis[v]\u0026\u0026!dfs(v))return 0; } vis[u]=1; topo.push_back(u); return 1; } bool toposort(){ topo.clear(); for(int i=0;i\u003c=n;i++)vis[i]=0; for(int u=1;u\u003c=n;u++){ if(!vis[u]\u0026\u0026!dfs(u))return 0; } reverse(topo.begin(),topo.end()); return 1; } inline void solve(){ cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++){ vis[i]=0; g[i].clear(); } e.clear(); for(int i=0;i\u003cm;i++){ int u,v,w; cin\u003e\u003ew\u003e\u003eu\u003e\u003ev; if(w){ g[u].push_back(v); in[v]++; }else e.push_back({u,v}); } if(!toposort()){ cout\u003c\u003c\"NO\"\u003c\u003cendl; return ; } for(int i=0;i\u003ctopo.size();i++)rk[topo[i]]=i; cout\u003c\u003c\"YES\"\u003c\u003cendl; for(int u=1;u\u003c=n;u++){ for(auto v:g[u])cout\u003c\u003cu\u003c\u003c\" \"\u003c\u003cv\u003c\u003cendl; } for(auto p:e){ if(rk[p.x]\u003crk[p.y])cout\u003c\u003cp.x\u003c\u003c\" \"\u003c\u003cp.y\u003c\u003cendl; else cout\u003c\u003cp.y\u003c\u003c\" \"\u003c\u003cp.x\u003c\u003cendl; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef pair\u003cint,int\u003e Pii; const int maxn=2e5+5; int n,m,rk[maxn]; vector\u003cPii\u003e e; void init(){} vector\u003cint\u003e g[maxn]; vector\u003cint\u003e topo; int in[maxn]; bool toposort(){ topo.clear(); for(int u=1;u\u003c=n;u++){ for(auto v:g[u])in[v]++; } int cnt=0; queue\u003cint\u003e q; for(int u=1;u\u003c=n;u++)if(!in[u])q.push(u); while(q.size()){ int u=q.front(); q.pop(); cnt++; topo.push_back(u); for(auto v:g[u])if(!--in[v])q.push(v); } return cnt==n; } inline void solve(){ cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++){ in[i]=0; g[i].clear(); } e.clear(); for(int i=0;i\u003cm;i++){ int u,v,w; cin\u003e\u003ew\u003e\u003eu\u003e\u003ev; if(w){ g[u].push_back(v); }else e.push_back({u,v}); } if(!toposort()){ cout\u003c\u003c\"NO\"\u003c\u003cendl; return ; } for(int i=0;i\u003ctopo.size();i++)rk[topo[i]]=i; cout\u003c\u003c\"YES\"\u003c\u003cendl; for(int u=1;u\u003c=n;u++){ for(auto v:g[u])cout\u003c\u003cu\u003c\u003c\" \"\u003c\u003cv\u003c\u003cendl; } for(auto p:e){ if(rk[p.x]\u003crk[p.y])cout\u003c\u003cp.x\u003c\u003c\" \"\u003c\u003cp.y\u003c\u003cendl; else cout\u003c\u003cp.y\u003c\u003c\" \"\u003c\u003cp.x\u003c\u003cendl; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; cin\u003e\u003e__; while(__--){ solve(); } return 0; } ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:3","tags":["codeforces","topological sorting"],"title":"Codeforces 1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"小结 很久没有刷过图论，通过这个题算是复习了一下拓扑排序 ","date":"2021-07-21","objectID":"/posts/cf1385e/:0:4","tags":["codeforces","topological sorting"],"title":"Codeforces 1385E Directing Edges","uri":"/posts/cf1385e/"},{"categories":["2021/7"],"content":"传送门 ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:0","tags":["codeforces","string hash"],"title":"Codeforces 1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"题意 给n个字符串合并成一个串并且合并时消除后一个串最长的与前一个串后缀相同的前缀，即ab与bc合并为abc ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:1","tags":["codeforces","string hash"],"title":"Codeforces 1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"思路 将字符串hash之后暴力寻找最长的相同前后缀即可。由于codeforces的数据还是比较强的，为了防止hash碰撞，有两种解决方法 双模数hash 在找到相同的hash值之后暴力判断该前缀和该后缀是否真正相同 ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:2","tags":["codeforces","string hash"],"title":"Codeforces 1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"代码 #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef unsigned long long ull; typedef pair\u003cull,ull\u003e P; const int md1=998244353; const int md2=1e9+7; const ull B1=233,B2=131; const int maxn=1e6+5; int n,m; string t,s; vector\u003cP\u003e pre,ss,tt; void init(){ pre.push_back(P(1,1)); for(int i=1;i\u003cmaxn;i++)pre.push_back(P(pre[i-1].x*B1%md1,pre[i-1].y*B2%md2)); } inline void solve(){ cin\u003e\u003en; t.push_back('*'); tt.push_back(P(0,0)); while(cin\u003e\u003es){ ss.clear(); ss.push_back(P(0,0)); for(int i=1;i\u003c=s.size();i++)ss.push_back(P((ss[i-1].x*B1+s[i-1])%md1,(ss[i-1].y*B2+s[i-1])%md2)); int len=0; for(int i=min(t.size(),s.size());i\u003e0;i--){ if((tt[t.size()-1].x+md1-tt[t.size()-i-1].x*pre[i].x%md1)%md1==ss[i].x \u0026\u0026(tt[t.size()-1].y+md2-tt[t.size()-i-1].y*pre[i].y%md2)%md2==ss[i].y){ len=i; break; } } for(int i=len,j=t.size();i\u003cs.size();i++,j++){ t.push_back(s[i]); tt.push_back(P((tt[j-1].x*B1+s[i])%md1,(tt[j-1].y*B2+s[i])%md2)); } } for(int i=1;i\u003ct.size();i++)cout\u003c\u003ct[i]; cout\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; init(); while(__--){ solve(); } return 0; } #include\u003cbits/stdc++.h\u003eusing namespace std; #define endl '\\n' #define x first #define y second typedef unsigned long long ull; const ull B=233; int n,m; string t,s; vector\u003cull\u003e pre,ss,tt; void init(){ pre.push_back(1); for(int i=1;i\u003cmaxn;i++)pre.push_back(pre[i-1]*B); } inline void solve(){ cin\u003e\u003en; t.push_back('*'); tt.push_back(0); while(cin\u003e\u003es){ ss.clear(); ss.push_back(0); for(int i=1;i\u003c=s.size();i++)ss.push_back(ss[i-1]*B+s[i-1]); int len=0; for(int i=min(t.size(),s.size());i\u003e0;i--){ if(tt[t.size()-1]-tt[t.size()-i-1]*pre[i]==ss[i]){ bool ok=1; for(int j=t.size()-i,k=0;j\u003ct.size()\u0026\u0026k\u003ci;j++,k++){ if(t[j]!=s[k]){ ok=0; break; } } if(ok){ len=i; break; } } } for(int i=len,j=t.size();i\u003cs.size();i++,j++){ t.push_back(s[i]); tt.push_back(tt[j-1]*B+s[i]); } } for(int i=1;i\u003ct.size();i++)cout\u003c\u003ct[i]; cout\u003c\u003cendl; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int __=1; init(); while(__--){ solve(); } return 0; } ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:3","tags":["codeforces","string hash"],"title":"Codeforces 1200E Compress Words","uri":"/posts/cf1200e/"},{"categories":["2021/7"],"content":"小结 不得不吐槽Codeforces的数据太狠了（可想当时比赛的时候被hack了多少人），主要注意的是unsigned long long 自然溢出这种hash方式貌似很容易被卡 ","date":"2021-07-18","objectID":"/posts/cf1200e/:0:4","tags":["codeforces","string hash"],"title":"Codeforces 1200E Compress Words","uri":"/posts/cf1200e/"}]